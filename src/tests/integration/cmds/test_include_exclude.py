# AUTOGENERATED! DO NOT EDIT!

import asyncio
import pytest
from pathlib import Path

from repoyard.cmds import (
    new_repo,
    sync_repo,
    exclude_repo,
    include_repo,
)
from repoyard._models import get_repoyard_meta, RepoPart
from repoyard.config import get_config

from ...integration.conftest import create_repoyards

@pytest.mark.integration
def test_include_exclude():
    """Test include/exclude operations for sparse checkout."""
    asyncio.run(_test_include_exclude())

async def _test_include_exclude():
    remote_name, remote_rclone_path, config, config_path, data_path = create_repoyards()
    repo_index_name = new_repo(
        config_path=config_path,
        repo_name="test-repo",
        storage_location=remote_name,
    )
    
    # Refresh config and get repo meta
    config = get_config(config_path)
    repoyard_meta = get_repoyard_meta(config, force_create=True)
    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    
    # Add some test data
    data_path = repo_meta.get_local_part_path(config, RepoPart.DATA)
    test_file = data_path / "test_data.txt"
    test_file.write_text("Hello, World!")
    
    # Sync to remote
    await sync_repo(config_path=config_path, repo_index_name=repo_index_name)
    assert repo_meta.check_included(config)
    assert test_file.exists()
    assert test_file.read_text() == "Hello, World!"
    await exclude_repo(config_path=config_path, repo_index_name=repo_index_name)
    
    # Refresh config
    config = get_config(config_path)
    repoyard_meta = get_repoyard_meta(config, force_create=True)
    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    assert not repo_meta.check_included(config)
    assert not test_file.exists()
    
    # Verify remote still has data
    from repoyard._utils import rclone_lsjson
    
    remote_files = await rclone_lsjson(
        config.rclone_config_path,
        source=remote_name,
        source_path=repo_meta.get_remote_path(config) + "/data",
    )
    assert remote_files is not None
    assert len(remote_files) > 0
    await include_repo(config_path=config_path, repo_index_name=repo_index_name)
    
    # Refresh config
    config = get_config(config_path)
    repoyard_meta = get_repoyard_meta(config, force_create=True)
    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    assert repo_meta.check_included(config)
    
    # Data should be restored
    data_path = repo_meta.get_local_part_path(config, RepoPart.DATA)
    test_file = data_path / "test_data.txt"
    assert test_file.exists()
    assert test_file.read_text() == "Hello, World!"
    # Make a local change
    test_file.write_text("Modified content!")
    
    # Exclude should push changes before removing
    await exclude_repo(config_path=config_path, repo_index_name=repo_index_name)
    
    # Include again to verify changes were pushed
    await include_repo(config_path=config_path, repo_index_name=repo_index_name)
    
    # Verify the modified content is there
    config = get_config(config_path)
    repoyard_meta = get_repoyard_meta(config, force_create=True)
    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    data_path = repo_meta.get_local_part_path(config, RepoPart.DATA)
    test_file = data_path / "test_data.txt"
    
    assert test_file.read_text() == "Modified content!"
    from repoyard.cmds import delete_repo
    
    await delete_repo(config_path=config_path, repo_index_name=repo_index_name)
