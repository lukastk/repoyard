# AUTOGENERATED! DO NOT EDIT! File to edit: pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py

__all__ = ['test_both_incomplete_different_ulids_is_error', 'test_interrupted_pull_retry_same_machine', 'test_interrupted_push_blocked_from_other_machine', 'test_interrupted_push_retry_same_machine', 'test_push_creates_incomplete_on_both_sides']

# %% pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py 2
import pytest
import asyncio
from pathlib import Path

from boxyard.cmds import (
    new_box,
    sync_box,
    sync_missing_boxmetas,
    include_box,
)
from boxyard._models import (
    get_boxyard_meta,
    get_sync_status,
    BoxPart,
    SyncRecord,
    SyncCondition,
)
from boxyard._utils.sync_helper import SyncUnsafe, SyncSetting, SyncDirection

from ...integration.conftest import create_boxyards


# ============================================================================
# Test: Interrupted push can be retried from the same machine
# ============================================================================

# %% pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py 3
@pytest.mark.integration
def test_interrupted_push_retry_same_machine():
    """
    Test that an interrupted push can be safely retried from the same machine.

    When a push is interrupted:
    1. Both local and remote have incomplete sync records with the SAME ULID
    2. The same machine (with matching incomplete ULIDs) can safely retry the push
    3. After retry, both sync records are complete with a new ULID
    """
    asyncio.run(_test_interrupted_push_retry_same_machine())


async def _test_interrupted_push_retry_same_machine():
    # Set up boxyard
    sl_name, sl_rclone_path, config, config_path, data_path = create_boxyards()

    # Create a box and sync it
    box_index_name = new_box(
        config_path=config_path,
        box_name="test_box",
        storage_location=sl_name,
    )
    await sync_box(config_path=config_path, box_index_name=box_index_name)

    # Get box meta
    boxyard_meta = get_boxyard_meta(config)
    box_meta = boxyard_meta.by_index_name[box_index_name]

    # Simulate an interrupted push by creating incomplete sync records with the SAME ULID
    incomplete_record = SyncRecord.create(sync_complete=False, syncer_hostname="test_host")

    local_sync_record_path = box_meta.get_local_sync_record_path(config, BoxPart.DATA)
    remote_sync_record_path = box_meta.get_remote_sync_record_path(config, BoxPart.DATA)

    # Save the same incomplete record to both local and remote (simulating interrupted push)
    local_sync_record_path.parent.mkdir(parents=True, exist_ok=True)
    local_sync_record_path.write_text(incomplete_record.model_dump_json())
    await incomplete_record.rclone_save(
        config.rclone_config_path,
        sl_name,
        remote_sync_record_path.as_posix(),
    )

    # Verify we're in SYNC_TO_REMOTE_INCOMPLETE state
    sync_status = await get_sync_status(
        rclone_config_path=config.rclone_config_path,
        local_path=box_meta.get_local_part_path(config, BoxPart.DATA),
        local_sync_record_path=local_sync_record_path,
        remote=sl_name,
        remote_path=box_meta.get_remote_part_path(config, BoxPart.DATA),
        remote_sync_record_path=remote_sync_record_path,
    )
    assert sync_status.sync_condition == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE

    # Retry the sync - should succeed because ULIDs match (same machine)
    await sync_box(
        config_path=config_path,
        box_index_name=box_index_name,
        sync_setting=SyncSetting.CAREFUL,  # Default safe mode
    )

    # Verify sync completed successfully
    sync_status = await get_sync_status(
        rclone_config_path=config.rclone_config_path,
        local_path=box_meta.get_local_part_path(config, BoxPart.DATA),
        local_sync_record_path=local_sync_record_path,
        remote=sl_name,
        remote_path=box_meta.get_remote_part_path(config, BoxPart.DATA),
        remote_sync_record_path=remote_sync_record_path,
    )
    assert sync_status.sync_condition == SyncCondition.SYNCED
    assert sync_status.local_sync_record.sync_complete is True
    assert sync_status.remote_sync_record.sync_complete is True


# ============================================================================
# Test: Interrupted push is blocked from another machine
# ============================================================================

# %% pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py 4
@pytest.mark.integration
def test_interrupted_push_blocked_from_other_machine():
    """
    Test that an interrupted push from machine A blocks syncs from machine B.

    When machine A's push is interrupted:
    1. Remote has incomplete sync record from machine A
    2. Machine B (different local state) cannot safely sync
    3. SyncUnsafe is raised with helpful message about "another machine"
    """
    asyncio.run(_test_interrupted_push_blocked_from_other_machine())


async def _test_interrupted_push_blocked_from_other_machine():
    # Set up two boxyards to simulate two machines
    (
        sl_name,
        sl_rclone_path,
        [(config1, config_path1, data_path1), (config2, config_path2, data_path2)],
    ) = create_boxyards(num_boxyards=2)

    # Create a box on machine 1 and sync it
    box_index_name = new_box(
        config_path=config_path1,
        box_name="test_box",
        storage_location=sl_name,
    )
    await sync_box(config_path=config_path1, box_index_name=box_index_name)

    # Sync boxmetas to machine 2 and include the box
    await sync_missing_boxmetas(config_path=config_path2)
    await include_box(config_path=config_path2, box_index_name=box_index_name)

    # Get box meta for both machines
    box_meta1 = get_boxyard_meta(config1).by_index_name[box_index_name]
    box_meta2 = get_boxyard_meta(config2).by_index_name[box_index_name]

    # Simulate an interrupted push from machine 1:
    # - Remote has incomplete record from machine 1's interrupted push
    # - Machine 1's local also has the same incomplete record
    incomplete_record_machine1 = SyncRecord.create(sync_complete=False, syncer_hostname="machine1")

    # Save incomplete record to remote (simulating machine 1's interrupted push)
    remote_sync_record_path = box_meta1.get_remote_sync_record_path(config1, BoxPart.DATA)
    await incomplete_record_machine1.rclone_save(
        config1.rclone_config_path,
        sl_name,
        remote_sync_record_path.as_posix(),
    )

    # Machine 2's local has its own COMPLETE sync record (from earlier successful sync)
    # This means machine 2 did NOT start the interrupted push

    # Verify the sync status from machine 2's perspective
    local_sync_record_path2 = box_meta2.get_local_sync_record_path(config2, BoxPart.DATA)
    sync_status = await get_sync_status(
        rclone_config_path=config2.rclone_config_path,
        local_path=box_meta2.get_local_part_path(config2, BoxPart.DATA),
        local_sync_record_path=local_sync_record_path2,
        remote=sl_name,
        remote_path=box_meta2.get_remote_part_path(config2, BoxPart.DATA),
        remote_sync_record_path=remote_sync_record_path,
    )
    assert sync_status.sync_condition == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE

    # Machine 2 should NOT be able to sync - it doesn't own the incomplete sync
    with pytest.raises(SyncUnsafe, match="another machine"):
        await sync_box(
            config_path=config_path2,
            box_index_name=box_index_name,
            sync_setting=SyncSetting.CAREFUL,
        )


# ============================================================================
# Test: Interrupted pull can be retried from the same machine
# ============================================================================

# %% pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py 5
@pytest.mark.integration
def test_interrupted_pull_retry_same_machine():
    """
    Test that an interrupted pull can be safely retried from the same machine.

    When a pull is interrupted:
    1. Only local has incomplete sync record (pull doesn't mark remote)
    2. Remote still has its complete record
    3. The same machine can safely retry the pull
    """
    asyncio.run(_test_interrupted_pull_retry_same_machine())


async def _test_interrupted_pull_retry_same_machine():
    # Set up two boxyards to simulate two machines
    (
        sl_name,
        sl_rclone_path,
        [(config1, config_path1, data_path1), (config2, config_path2, data_path2)],
    ) = create_boxyards(num_boxyards=2)

    # Create a box on machine 1 and sync it
    box_index_name = new_box(
        config_path=config_path1,
        box_name="test_box",
        storage_location=sl_name,
    )
    await sync_box(config_path=config_path1, box_index_name=box_index_name)

    # Sync boxmetas to machine 2 and include the box
    await sync_missing_boxmetas(config_path=config_path2)
    await include_box(config_path=config_path2, box_index_name=box_index_name)

    # Get box meta
    box_meta2 = get_boxyard_meta(config2).by_index_name[box_index_name]

    # Simulate an interrupted pull on machine 2:
    # - Local has incomplete record (pull was interrupted)
    # - Remote still has complete record (pull doesn't touch remote)
    incomplete_record = SyncRecord.create(sync_complete=False, syncer_hostname="machine2")

    local_sync_record_path = box_meta2.get_local_sync_record_path(config2, BoxPart.DATA)
    local_sync_record_path.parent.mkdir(parents=True, exist_ok=True)
    local_sync_record_path.write_text(incomplete_record.model_dump_json())

    # Verify we're in SYNC_FROM_REMOTE_INCOMPLETE state
    remote_sync_record_path = box_meta2.get_remote_sync_record_path(config2, BoxPart.DATA)
    sync_status = await get_sync_status(
        rclone_config_path=config2.rclone_config_path,
        local_path=box_meta2.get_local_part_path(config2, BoxPart.DATA),
        local_sync_record_path=local_sync_record_path,
        remote=sl_name,
        remote_path=box_meta2.get_remote_part_path(config2, BoxPart.DATA),
        remote_sync_record_path=remote_sync_record_path,
    )
    assert sync_status.sync_condition == SyncCondition.SYNC_FROM_REMOTE_INCOMPLETE

    # Retry the sync - should succeed (local incomplete = this machine owns it)
    await sync_box(
        config_path=config_path2,
        box_index_name=box_index_name,
        sync_setting=SyncSetting.CAREFUL,
    )

    # Verify sync completed successfully
    sync_status = await get_sync_status(
        rclone_config_path=config2.rclone_config_path,
        local_path=box_meta2.get_local_part_path(config2, BoxPart.DATA),
        local_sync_record_path=local_sync_record_path,
        remote=sl_name,
        remote_path=box_meta2.get_remote_part_path(config2, BoxPart.DATA),
        remote_sync_record_path=remote_sync_record_path,
    )
    assert sync_status.sync_condition == SyncCondition.SYNCED


# ============================================================================
# Test: Both incomplete with different ULIDs returns ERROR
# ============================================================================

# %% pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py 6
@pytest.mark.integration
def test_both_incomplete_different_ulids_is_error():
    """
    Test that having both local and remote incomplete with different ULIDs
    results in an ERROR condition.

    This shouldn't happen in normal operation but could occur due to:
    - Manual tampering
    - Bug in previous version
    - File corruption
    """
    asyncio.run(_test_both_incomplete_different_ulids_is_error())


async def _test_both_incomplete_different_ulids_is_error():
    import time

    # Set up boxyard
    sl_name, sl_rclone_path, config, config_path, data_path = create_boxyards()

    # Create a box and sync it
    box_index_name = new_box(
        config_path=config_path,
        box_name="test_box",
        storage_location=sl_name,
    )
    await sync_box(config_path=config_path, box_index_name=box_index_name)

    # Get box meta
    boxyard_meta = get_boxyard_meta(config)
    box_meta = boxyard_meta.by_index_name[box_index_name]

    # Create two DIFFERENT incomplete records (different ULIDs)
    incomplete_record_local = SyncRecord.create(sync_complete=False, syncer_hostname="machine_a")
    time.sleep(0.002)  # Ensure different ULIDs
    incomplete_record_remote = SyncRecord.create(sync_complete=False, syncer_hostname="machine_b")

    # Verify ULIDs are different
    assert incomplete_record_local.ulid != incomplete_record_remote.ulid

    local_sync_record_path = box_meta.get_local_sync_record_path(config, BoxPart.DATA)
    remote_sync_record_path = box_meta.get_remote_sync_record_path(config, BoxPart.DATA)

    # Save different incomplete records to local and remote
    local_sync_record_path.parent.mkdir(parents=True, exist_ok=True)
    local_sync_record_path.write_text(incomplete_record_local.model_dump_json())
    await incomplete_record_remote.rclone_save(
        config.rclone_config_path,
        sl_name,
        remote_sync_record_path.as_posix(),
    )

    # Verify we're in ERROR state
    sync_status = await get_sync_status(
        rclone_config_path=config.rclone_config_path,
        local_path=box_meta.get_local_part_path(config, BoxPart.DATA),
        local_sync_record_path=local_sync_record_path,
        remote=sl_name,
        remote_path=box_meta.get_remote_part_path(config, BoxPart.DATA),
        remote_sync_record_path=remote_sync_record_path,
    )
    assert sync_status.sync_condition == SyncCondition.ERROR
    assert "inconsistent incomplete records" in sync_status.error_message.lower()

    # Sync should raise exception due to ERROR state (unless FORCE)
    with pytest.raises(Exception, match="[Ii]nconsistent"):
        await sync_box(
            config_path=config_path,
            box_index_name=box_index_name,
            sync_setting=SyncSetting.CAREFUL,
        )


# ============================================================================
# Test: Push creates incomplete records on both sides before syncing
# ============================================================================

# %% pts/tests/integration/sync/test_interrupted_sync_recovery.pct.py 7
@pytest.mark.integration
def test_push_creates_incomplete_on_both_sides():
    """
    Test that a push operation creates incomplete sync records on BOTH
    local and remote before starting the actual sync.

    This is the mechanism that enables safe retries:
    - Same ULID on both sides proves ownership
    - If interrupted, the matching ULIDs allow retry
    """
    asyncio.run(_test_push_creates_incomplete_on_both_sides())


async def _test_push_creates_incomplete_on_both_sides():
    # Set up boxyard
    sl_name, sl_rclone_path, config, config_path, data_path = create_boxyards()

    # Create a box
    box_index_name = new_box(
        config_path=config_path,
        box_name="test_box",
        storage_location=sl_name,
    )

    # Get box meta
    boxyard_meta = get_boxyard_meta(config)
    box_meta = boxyard_meta.by_index_name[box_index_name]

    # Do the initial sync (push)
    await sync_box(config_path=config_path, box_index_name=box_index_name)

    # Verify both records exist and are complete with matching ULIDs
    local_sync_record_path = box_meta.get_local_sync_record_path(config, BoxPart.DATA)
    remote_sync_record_path = box_meta.get_remote_sync_record_path(config, BoxPart.DATA)

    local_record = SyncRecord.model_validate_json(local_sync_record_path.read_text())
    remote_record = await SyncRecord.rclone_read(
        config.rclone_config_path,
        sl_name,
        remote_sync_record_path.as_posix(),
    )

    # Both should be complete
    assert local_record.sync_complete is True
    assert remote_record.sync_complete is True

    # ULIDs should match (proves they came from the same sync operation)
    assert local_record.ulid == remote_record.ulid
