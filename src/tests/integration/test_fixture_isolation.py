# AUTOGENERATED! DO NOT EDIT! File to edit: pts/tests/integration/test_fixture_isolation.pct.py

__all__ = ['test_local_fixture_can_create_and_sync_repo', 'test_local_fixture_creates_isolated_environment', 'test_local_fixture_locks_are_isolated', 'test_remote_fixture_skips_without_config']

# %% pts/tests/integration/test_fixture_isolation.pct.py 3
import pytest
from pathlib import Path

from repoyard.cmds import new_repo, sync_repo, delete_repo
from repoyard._models import get_repoyard_meta


# ============================================================================
# Tests using local fixtures
# ============================================================================

# %% pts/tests/integration/test_fixture_isolation.pct.py 4
@pytest.mark.integration
def test_local_fixture_creates_isolated_environment(test_repoyard_local):
    """Test that the local fixture creates a fully isolated environment."""
    env = test_repoyard_local

    # Verify all paths exist and are in the tmp directory
    assert env["config_path"].exists()
    assert env["data_path"].exists()
    assert env["local_store"].exists()
    assert env["remote_storage"].exists()

    # Verify paths are not in the user's home directory
    home = Path.home()
    assert not str(env["config_path"]).startswith(str(home / ".config"))
    assert not str(env["data_path"]).startswith(str(home / ".repoyard"))

    # Verify lock directory path is isolated (created on demand when locks are acquired)
    lock_dir = env["data_path"] / "locks"
    assert not str(lock_dir).startswith(str(home))


@pytest.mark.integration
def test_local_fixture_can_create_and_sync_repo(test_repoyard_local):
    """Test that we can create and sync a repo using the local fixture."""
    import asyncio

    env = test_repoyard_local

    # Create a new repo
    repo_index_name = new_repo(
        config_path=env["config_path"],
        repo_name="test_repo",
        storage_location=env["storage_location_name"],
    )

    # Verify repo was created
    repoyard_meta = get_repoyard_meta(env["config"])
    assert repo_index_name in repoyard_meta.by_index_name

    # Sync the repo
    asyncio.run(sync_repo(
        config_path=env["config_path"],
        repo_index_name=repo_index_name,
    ))

    # Verify sync completed by checking local repo still exists
    # (Remote path structure depends on rclone config which varies)
    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    local_repo_path = repo_meta.get_local_path(env["config"])
    assert local_repo_path.exists()


@pytest.mark.integration
def test_local_fixture_locks_are_isolated(test_repoyard_local):
    """Test that locks are created in the isolated data directory."""
    import asyncio

    env = test_repoyard_local

    # Create a repo (this should acquire a global lock)
    repo_index_name = new_repo(
        config_path=env["config_path"],
        repo_name="lock_test_repo",
        storage_location=env["storage_location_name"],
    )

    # Check that any lock files are in the isolated directory
    lock_dir = env["data_path"] / "locks"
    user_lock_dir = Path.home() / ".repoyard" / "locks"

    # The user's lock directory should not have been touched
    # (We can't assert it doesn't exist since it might have existed before)
    # But we can verify our lock directory exists
    assert lock_dir.exists()

    # Clean up
    asyncio.run(delete_repo(
        config_path=env["config_path"],
        repo_index_name=repo_index_name,
    ))


# ============================================================================
# Tests using remote fixtures
# ============================================================================

# %% pts/tests/integration/test_fixture_isolation.pct.py 5
@pytest.mark.integration
@pytest.mark.remote
def test_remote_fixture_skips_without_config(test_repoyard_remote):
    """Test that remote fixture properly loads when config exists.

    Note: This test will be skipped if repoyard_rclone.conf doesn't exist
    in tests/fixtures/configs/default_remote/
    """
    env = test_repoyard_remote

    # If we got here, the config exists
    assert env.get("has_remote", False)
    assert env["config_path"].exists()

    # Verify the storage location uses 'repoyard-test' to avoid pollution
    config = env["config"]
    storage_loc = config.storage_locations.get("test_remote")
    assert storage_loc is not None
    assert storage_loc.store_path == "repoyard-test"
