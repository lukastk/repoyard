# AUTOGENERATED! DO NOT EDIT! File to edit: pts/tests/unit/models/test_repo_meta.pct.py

__all__ = ['TestCheckIncluded', 'TestCreationTimestampDatetime', 'TestIndexName', 'TestPathGeneration', 'TestRepoId', 'TestRepoMetaCreate', 'TestRepoMetaValidation', 'TestRepoPart', 'TestValidateGroupName']

# %% pts/tests/unit/models/test_repo_meta.pct.py 2
import pytest
from datetime import datetime, timezone
from pathlib import Path
from unittest.mock import MagicMock, patch
from pydantic import ValidationError

from repoyard._models import RepoMeta, RepoPart
from repoyard import const


# ============================================================================
# Tests for repo_id property
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 3
class TestRepoId:
    """Tests for the repo_id property."""

    def test_repo_id_with_datetime_timestamp(self):
        """repo_id combines timestamp and subid correctly for datetime format."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta.repo_id == "20251122_143022_a7kx9"

    def test_repo_id_with_date_only_timestamp(self):
        """repo_id combines timestamp and subid correctly for date-only format."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122",
            repo_subid="b8ly0",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta.repo_id == "20251122_b8ly0"

    def test_repo_id_different_subids(self):
        """Different subids produce different repo_ids."""
        repo_meta1 = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        repo_meta2 = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="z9abc",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta1.repo_id != repo_meta2.repo_id


# ============================================================================
# Tests for index_name property
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 4
class TestIndexName:
    """Tests for the index_name property."""

    def test_index_name_format(self):
        """index_name combines repo_id and name with double underscore."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta.index_name == "20251122_143022_a7kx9__myproject"

    def test_index_name_with_date_only(self):
        """index_name works with date-only timestamp format."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122",
            repo_subid="b8ly0",
            name="testproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta.index_name == "20251122_b8ly0__testproject"

    def test_index_name_with_special_name(self):
        """index_name handles names with hyphens and underscores."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="my-test_project",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta.index_name == "20251122_143022_a7kx9__my-test_project"


# ============================================================================
# Tests for creation_timestamp_datetime property
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 5
class TestCreationTimestampDatetime:
    """Tests for the creation_timestamp_datetime property."""

    def test_datetime_timestamp_parsing(self):
        """Parses datetime format timestamp correctly."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        dt = repo_meta.creation_timestamp_datetime
        assert dt.year == 2025
        assert dt.month == 11
        assert dt.day == 22
        assert dt.hour == 14
        assert dt.minute == 30
        assert dt.second == 22

    def test_date_only_timestamp_parsing(self):
        """Parses date-only format timestamp correctly."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        dt = repo_meta.creation_timestamp_datetime
        assert dt.year == 2025
        assert dt.month == 11
        assert dt.day == 22
        # Time components should be zero for date-only
        assert dt.hour == 0
        assert dt.minute == 0
        assert dt.second == 0


# ============================================================================
# Tests for validate_group_name
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 6
class TestValidateGroupName:
    """Tests for the validate_group_name class method."""

    def test_valid_alphanumeric(self):
        """Valid alphanumeric group names."""
        RepoMeta.validate_group_name("group1")
        RepoMeta.validate_group_name("GROUP1")
        RepoMeta.validate_group_name("Group123")

    def test_valid_with_underscore(self):
        """Valid group names with underscores."""
        RepoMeta.validate_group_name("my_group")
        RepoMeta.validate_group_name("test_group_123")
        RepoMeta.validate_group_name("_underscore")

    def test_valid_with_hyphen(self):
        """Valid group names with hyphens."""
        RepoMeta.validate_group_name("my-group")
        RepoMeta.validate_group_name("test-group-123")
        RepoMeta.validate_group_name("-hyphen")

    def test_valid_with_slash(self):
        """Valid group names with slashes (for hierarchical groups)."""
        RepoMeta.validate_group_name("parent/child")
        RepoMeta.validate_group_name("a/b/c")
        RepoMeta.validate_group_name("projects/backend/api")

    def test_invalid_with_space(self):
        """Group names with spaces are invalid."""
        with pytest.raises(ValueError, match="Invalid group name"):
            RepoMeta.validate_group_name("my group")

    def test_invalid_with_special_chars(self):
        """Group names with special characters are invalid."""
        invalid_names = ["group@test", "group#1", "group$", "group%", "group&"]
        for name in invalid_names:
            with pytest.raises(ValueError, match="Invalid group name"):
                RepoMeta.validate_group_name(name)

    def test_invalid_empty_string(self):
        """Empty string is invalid."""
        with pytest.raises(ValueError, match="Invalid group name"):
            RepoMeta.validate_group_name("")

    def test_invalid_non_string(self):
        """Non-string values are invalid."""
        with pytest.raises(ValueError, match="Invalid group name"):
            RepoMeta.validate_group_name(123)
        with pytest.raises(ValueError, match="Invalid group name"):
            RepoMeta.validate_group_name(None)


# ============================================================================
# Tests for RepoMeta validation
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 7
class TestRepoMetaValidation:
    """Tests for RepoMeta model validation."""

    def test_duplicate_groups_rejected(self):
        """Duplicate groups in the list are rejected."""
        with pytest.raises(ValidationError, match="Groups must be unique"):
            RepoMeta(
                creation_timestamp_utc="20251122_143022",
                repo_subid="a7kx9",
                name="myproject",
                storage_location="default",
                creator_hostname="myhost",
                groups=["group1", "group1"],
            )

    def test_invalid_group_name_in_list_rejected(self):
        """Invalid group names in the list are rejected."""
        with pytest.raises(ValidationError, match="Invalid group name"):
            RepoMeta(
                creation_timestamp_utc="20251122_143022",
                repo_subid="a7kx9",
                name="myproject",
                storage_location="default",
                creator_hostname="myhost",
                groups=["valid", "invalid name with space"],
            )

    def test_invalid_timestamp_format_rejected(self):
        """Invalid timestamp formats are rejected."""
        with pytest.raises(ValidationError, match="Creation timestamp is not valid"):
            RepoMeta(
                creation_timestamp_utc="2025-11-22",  # Wrong format
                repo_subid="a7kx9",
                name="myproject",
                storage_location="default",
                creator_hostname="myhost",
                groups=[],
            )

    def test_invalid_timestamp_value_rejected(self):
        """Invalid timestamp values are rejected."""
        with pytest.raises(ValidationError, match="Creation timestamp is not valid"):
            RepoMeta(
                creation_timestamp_utc="20251399_143022",  # Invalid month
                repo_subid="a7kx9",
                name="myproject",
                storage_location="default",
                creator_hostname="myhost",
                groups=[],
            )

    def test_valid_repo_meta_creation(self):
        """Valid RepoMeta can be created."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=["group1", "group2"],
        )
        assert repo_meta.name == "myproject"
        assert repo_meta.groups == ["group1", "group2"]

    def test_empty_groups_allowed(self):
        """Empty groups list is allowed."""
        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )
        assert repo_meta.groups == []


# ============================================================================
# Tests for RepoMeta.create factory method
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 8
class TestRepoMetaCreate:
    """Tests for the RepoMeta.create factory method."""

    def test_create_with_datetime_format(self):
        """Create generates proper repo with datetime format."""
        from repoyard.config import Config, StorageConfig, StorageType, RepoTimestampFormat

        mock_config = MagicMock(spec=Config)
        mock_config.repo_timestamp_format = RepoTimestampFormat.DATE_AND_TIME
        mock_config.repo_subid_character_set = "abcdefghijklmnopqrstuvwxyz0123456789"
        mock_config.repo_subid_length = 5

        repo_meta = RepoMeta.create(
            config=mock_config,
            name="testproject",
            storage_location_name="default",
            creator_hostname="testhost",
            groups=["group1"],
        )

        # Check that timestamp is datetime format (contains underscore in time part)
        assert "_" in repo_meta.creation_timestamp_utc
        assert len(repo_meta.repo_subid) == 5
        assert repo_meta.name == "testproject"
        assert repo_meta.storage_location == "default"
        assert repo_meta.creator_hostname == "testhost"
        assert repo_meta.groups == ["group1"]

    def test_create_with_date_only_format(self):
        """Create generates proper repo with date-only format."""
        from repoyard.config import Config, StorageConfig, StorageType, RepoTimestampFormat

        mock_config = MagicMock(spec=Config)
        mock_config.repo_timestamp_format = RepoTimestampFormat.DATE_ONLY
        mock_config.repo_subid_character_set = "abcdefghijklmnopqrstuvwxyz0123456789"
        mock_config.repo_subid_length = 5

        repo_meta = RepoMeta.create(
            config=mock_config,
            name="testproject",
            storage_location_name="default",
            creator_hostname="testhost",
            groups=[],
        )

        # Check that timestamp is date-only format (no underscore separating time)
        # The format is YYYYMMDD, which doesn't have an underscore
        # But we need to be careful: the timestamp might have one underscore
        # from the format YYYYMMDD_HHMMSS. Date-only has no underscore.
        timestamp = repo_meta.creation_timestamp_utc
        # Date only format is just 8 digits
        assert len(timestamp) == 8
        assert timestamp.isdigit()

    def test_create_generates_unique_subids(self):
        """Create generates different subids on each call."""
        from repoyard.config import Config, RepoTimestampFormat

        mock_config = MagicMock(spec=Config)
        mock_config.repo_timestamp_format = RepoTimestampFormat.DATE_AND_TIME
        mock_config.repo_subid_character_set = "abcdefghijklmnopqrstuvwxyz0123456789"
        mock_config.repo_subid_length = 5

        subids = set()
        for _ in range(100):
            repo_meta = RepoMeta.create(
                config=mock_config,
                name="test",
                storage_location_name="default",
                creator_hostname="host",
                groups=[],
            )
            subids.add(repo_meta.repo_subid)

        # With 36^5 = 60,466,176 possibilities, getting 100 unique is expected
        # Allow for some small chance of collision but expect at least 95 unique
        assert len(subids) >= 95


# ============================================================================
# Tests for path generation methods
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 9
class TestPathGeneration:
    """Tests for path generation methods."""

    @pytest.fixture
    def mock_config(self):
        """Create a mock config for path tests."""
        from repoyard.config import Config, StorageConfig, StorageType

        config = MagicMock(spec=Config)
        config.local_store_path = Path("/home/user/.repoyard/local_store")
        config.user_repos_path = Path("/home/user/repos")
        config.repoyard_data_path = Path("/home/user/.repoyard")

        storage_config = MagicMock(spec=StorageConfig)
        storage_config.store_path = Path("remote:bucket/repoyard")
        config.storage_locations = {"default": storage_config}

        return config

    @pytest.fixture
    def repo_meta(self):
        """Create a test RepoMeta instance."""
        return RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )

    def test_get_local_path(self, mock_config, repo_meta):
        """get_local_path returns correct path."""
        local_path = repo_meta.get_local_path(mock_config)
        expected = Path("/home/user/.repoyard/local_store/default/20251122_143022_a7kx9__myproject")
        assert local_path == expected

    def test_get_remote_path(self, mock_config, repo_meta):
        """get_remote_path returns correct path."""
        remote_path = repo_meta.get_remote_path(mock_config)
        expected = Path("remote:bucket/repoyard/repos/20251122_143022_a7kx9__myproject")
        assert remote_path == expected

    def test_get_local_part_path_data(self, mock_config, repo_meta):
        """get_local_part_path returns correct path for DATA."""
        data_path = repo_meta.get_local_part_path(mock_config, RepoPart.DATA)
        expected = Path("/home/user/repos/20251122_143022_a7kx9__myproject")
        assert data_path == expected

    def test_get_local_part_path_meta(self, mock_config, repo_meta):
        """get_local_part_path returns correct path for META."""
        meta_path = repo_meta.get_local_part_path(mock_config, RepoPart.META)
        expected = Path("/home/user/.repoyard/local_store/default/20251122_143022_a7kx9__myproject/repometa.toml")
        assert meta_path == expected

    def test_get_local_part_path_conf(self, mock_config, repo_meta):
        """get_local_part_path returns correct path for CONF."""
        conf_path = repo_meta.get_local_part_path(mock_config, RepoPart.CONF)
        expected = Path("/home/user/.repoyard/local_store/default/20251122_143022_a7kx9__myproject/conf")
        assert conf_path == expected

    def test_get_remote_part_path_data(self, mock_config, repo_meta):
        """get_remote_part_path returns correct path for DATA."""
        data_path = repo_meta.get_remote_part_path(mock_config, RepoPart.DATA)
        expected = Path("remote:bucket/repoyard/repos/20251122_143022_a7kx9__myproject/data")
        assert data_path == expected

    def test_get_remote_part_path_meta(self, mock_config, repo_meta):
        """get_remote_part_path returns correct path for META."""
        meta_path = repo_meta.get_remote_part_path(mock_config, RepoPart.META)
        expected = Path("remote:bucket/repoyard/repos/20251122_143022_a7kx9__myproject/repometa.toml")
        assert meta_path == expected

    def test_get_remote_part_path_conf(self, mock_config, repo_meta):
        """get_remote_part_path returns correct path for CONF."""
        conf_path = repo_meta.get_remote_part_path(mock_config, RepoPart.CONF)
        expected = Path("remote:bucket/repoyard/repos/20251122_143022_a7kx9__myproject/conf")
        assert conf_path == expected

    def test_get_local_sync_record_path(self, mock_config, repo_meta):
        """get_local_sync_record_path returns correct path."""
        for part in RepoPart:
            sync_path = repo_meta.get_local_sync_record_path(mock_config, part)
            expected = Path(f"/home/user/.repoyard/sync_records/20251122_143022_a7kx9__myproject/{part.value}.rec")
            assert sync_path == expected

    def test_get_remote_sync_record_path(self, mock_config, repo_meta):
        """get_remote_sync_record_path returns correct path."""
        for part in RepoPart:
            sync_path = repo_meta.get_remote_sync_record_path(mock_config, part)
            expected = Path(f"remote:bucket/repoyard/sync_records/20251122_143022_a7kx9__myproject/{part.value}.rec")
            assert sync_path == expected

    def test_invalid_repo_part_raises_error(self, mock_config, repo_meta):
        """Invalid repo part raises ValueError."""
        # This test documents expected behavior - we can't easily test with
        # an invalid enum value, but we verify the paths are correct for all valid parts
        pass


# ============================================================================
# Tests for check_included
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 10
class TestCheckIncluded:
    """Tests for the check_included method."""

    def test_check_included_when_data_dir_exists(self, tmp_path):
        """check_included returns True when data directory exists."""
        from repoyard.config import Config

        mock_config = MagicMock(spec=Config)
        mock_config.user_repos_path = tmp_path

        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )

        # Create the data directory
        data_dir = tmp_path / repo_meta.index_name
        data_dir.mkdir()

        assert repo_meta.check_included(mock_config) is True

    def test_check_included_when_data_dir_not_exists(self, tmp_path):
        """check_included returns False when data directory doesn't exist."""
        from repoyard.config import Config

        mock_config = MagicMock(spec=Config)
        mock_config.user_repos_path = tmp_path

        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )

        assert repo_meta.check_included(mock_config) is False

    def test_check_included_when_data_is_file(self, tmp_path):
        """check_included returns False when path exists but is a file."""
        from repoyard.config import Config

        mock_config = MagicMock(spec=Config)
        mock_config.user_repos_path = tmp_path

        repo_meta = RepoMeta(
            creation_timestamp_utc="20251122_143022",
            repo_subid="a7kx9",
            name="myproject",
            storage_location="default",
            creator_hostname="myhost",
            groups=[],
        )

        # Create a file instead of directory
        data_file = tmp_path / repo_meta.index_name
        data_file.write_text("not a directory")

        assert repo_meta.check_included(mock_config) is False


# ============================================================================
# Tests for RepoPart enum
# ============================================================================

# %% pts/tests/unit/models/test_repo_meta.pct.py 11
class TestRepoPart:
    """Tests for the RepoPart enum."""

    def test_repo_part_values(self):
        """RepoPart has correct values."""
        assert RepoPart.DATA.value == "data"
        assert RepoPart.META.value == "meta"
        assert RepoPart.CONF.value == "conf"

    def test_repo_part_iteration(self):
        """All RepoPart values can be iterated."""
        parts = list(RepoPart)
        assert len(parts) == 3
        assert RepoPart.DATA in parts
        assert RepoPart.META in parts
        assert RepoPart.CONF in parts
