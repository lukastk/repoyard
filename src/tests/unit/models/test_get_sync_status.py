# AUTOGENERATED! DO NOT EDIT! File to edit: pts/tests/unit/models/test_get_sync_status.pct.py

__all__ = ['TestGetSyncStatusBasicScenarios', 'TestGetSyncStatusConflict', 'TestGetSyncStatusErrors', 'TestGetSyncStatusIncomplete', 'TestGetSyncStatusNeedsPull', 'TestGetSyncStatusNeedsPush', 'TestGetSyncStatusReturnValue', 'TestGetSyncStatusSynced', 'TestGetSyncStatusTypeMismatch', 'make_sync_record']

# %% pts/tests/unit/models/test_get_sync_status.pct.py 2
import pytest
import asyncio
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, patch, AsyncMock
from datetime import datetime, timezone, timedelta
from ulid import ULID

from boxyard._models import get_sync_status, SyncCondition, SyncStatus, SyncRecord


# ============================================================================
# Helper fixtures
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 3
def make_sync_record(sync_complete=True, timestamp_offset_ms=0):
    """Create a SyncRecord with optional timestamp offset."""
    import time
    if timestamp_offset_ms:
        time.sleep(timestamp_offset_ms / 1000)
    return SyncRecord.create(sync_complete=sync_complete, syncer_hostname="testhost")


# ============================================================================
# Tests for basic sync status scenarios
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 4
class TestGetSyncStatusBasicScenarios:
    """Tests for basic get_sync_status scenarios."""

    def test_neither_local_nor_remote_exists(self):
        """Returns SYNCED when neither local nor remote exists."""
        async def _test():
            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(return_value=(False, False)),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=None),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path="/local/path",
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.SYNCED
            assert status.local_path_exists is False
            assert status.remote_path_exists is False

        asyncio.run(_test())

    def test_local_exists_remote_does_not_needs_push(self, tmp_path):
        """Returns NEEDS_PUSH when local exists but remote does not."""
        async def _test():
            # Create actual local directory (empty)
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (False, False),  # remote doesn't exist
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=None),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,  # Pass Path object
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.NEEDS_PUSH
            assert status.local_path_exists is True
            assert status.remote_path_exists is False

        asyncio.run(_test())

    def test_remote_exists_local_does_not_excluded(self):
        """Returns EXCLUDED when remote exists but local does not."""
        async def _test():
            mock_record = MagicMock(spec=SyncRecord)
            mock_record.sync_complete = True

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (False, False),  # local doesn't exist
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=None,
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[
                        None,  # local sync record
                        mock_record,  # remote sync record
                    ]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path="/local/path",
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.EXCLUDED
            assert status.local_path_exists is False
            assert status.remote_path_exists is True

        asyncio.run(_test())


# ============================================================================
# Tests for synced state
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 5
class TestGetSyncStatusSynced:
    """Tests for SYNCED condition."""

    def test_synced_when_records_match_no_local_changes(self, tmp_path):
        """Returns SYNCED when records match and no local changes."""
        async def _test():
            # Create actual local directory
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            shared_ulid = ULID()
            mock_record = MagicMock(spec=SyncRecord)
            mock_record.ulid = shared_ulid
            mock_record.sync_complete = True
            mock_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=mock_record.timestamp - timedelta(hours=1),  # Modified before sync
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=mock_record),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.SYNCED
            assert status.local_path_exists is True
            assert status.remote_path_exists is True

        asyncio.run(_test())


# ============================================================================
# Tests for needs push/pull
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 6
class TestGetSyncStatusNeedsPush:
    """Tests for NEEDS_PUSH condition."""

    def test_needs_push_when_local_modified_after_sync(self, tmp_path):
        """Returns NEEDS_PUSH when local was modified after last sync."""
        async def _test():
            # Create actual local directory
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            shared_ulid = ULID()
            mock_record = MagicMock(spec=SyncRecord)
            mock_record.ulid = shared_ulid
            mock_record.sync_complete = True
            mock_record.timestamp = datetime.now(timezone.utc) - timedelta(hours=2)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),  # Modified after sync
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=mock_record),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.NEEDS_PUSH

        asyncio.run(_test())

# %% pts/tests/unit/models/test_get_sync_status.pct.py 7
class TestGetSyncStatusNeedsPull:
    """Tests for NEEDS_PULL condition."""

    def test_needs_pull_when_remote_more_recent(self, tmp_path):
        """Returns NEEDS_PULL when remote sync record is more recent."""
        async def _test():
            # Create actual local directory
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = True
            local_record.timestamp = datetime.now(timezone.utc) - timedelta(hours=2)

            # Create a more recent remote record
            import time
            time.sleep(0.002)
            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()
            remote_record.sync_complete = True
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=local_record.timestamp - timedelta(hours=1),  # No local changes
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.NEEDS_PULL

        asyncio.run(_test())


# ============================================================================
# Tests for conflict
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 8
class TestGetSyncStatusConflict:
    """Tests for CONFLICT condition."""

    def test_conflict_when_both_modified(self, tmp_path):
        """Returns CONFLICT when both local and remote have changes."""
        async def _test():
            # Create actual local directory
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = True
            local_record.timestamp = datetime.now(timezone.utc) - timedelta(hours=2)

            # Create a more recent remote record
            import time
            time.sleep(0.002)
            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()
            remote_record.sync_complete = True
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),  # Local also modified
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.CONFLICT

        asyncio.run(_test())

    def test_conflict_when_local_more_recent(self, tmp_path):
        """Returns CONFLICT when local sync record is more recent than remote."""
        async def _test():
            # Create actual local directory
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            # Remote record is older
            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()
            remote_record.sync_complete = True
            remote_record.timestamp = datetime.now(timezone.utc) - timedelta(hours=2)

            # Create a more recent local record
            import time
            time.sleep(0.002)
            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = True
            local_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=local_record.timestamp - timedelta(hours=1),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.CONFLICT

        asyncio.run(_test())


# ============================================================================
# Tests for sync incomplete
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 9
class TestGetSyncStatusIncomplete:
    """Tests for SYNC_TO_REMOTE_INCOMPLETE and SYNC_FROM_REMOTE_INCOMPLETE conditions."""

    def test_sync_from_remote_incomplete_when_local_sync_incomplete(self, tmp_path):
        """Returns SYNC_FROM_REMOTE_INCOMPLETE when local sync record is incomplete (pull interrupted)."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = False  # Incomplete!
            local_record.timestamp = datetime.now(timezone.utc)

            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()
            remote_record.sync_complete = True
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.SYNC_FROM_REMOTE_INCOMPLETE

        asyncio.run(_test())

    def test_sync_to_remote_incomplete_when_remote_sync_incomplete(self, tmp_path):
        """Returns SYNC_TO_REMOTE_INCOMPLETE when remote sync record is incomplete (push interrupted)."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = True
            local_record.timestamp = datetime.now(timezone.utc)

            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()
            remote_record.sync_complete = False  # Incomplete!
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE

        asyncio.run(_test())

    def test_sync_to_remote_incomplete_when_both_incomplete_matching_ulids(self, tmp_path):
        """Returns SYNC_TO_REMOTE_INCOMPLETE when both are incomplete with matching ULIDs (push interrupted from this machine)."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            shared_ulid = ULID()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = shared_ulid
            local_record.sync_complete = False  # Incomplete!
            local_record.timestamp = datetime.now(timezone.utc)

            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = shared_ulid  # Same ULID
            remote_record.sync_complete = False  # Also incomplete!
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE

        asyncio.run(_test())

    def test_error_when_both_incomplete_different_ulids(self, tmp_path):
        """Returns ERROR when both are incomplete with different ULIDs (inconsistent state)."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = False  # Incomplete!
            local_record.timestamp = datetime.now(timezone.utc)

            import time
            time.sleep(0.002)
            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()  # Different ULID
            remote_record.sync_complete = False  # Also incomplete!
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, True),  # remote exists, is dir
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, remote_record]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.ERROR
            assert "inconsistent incomplete records" in status.error_message.lower()

        asyncio.run(_test())


# ============================================================================
# Tests for error conditions
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 10
class TestGetSyncStatusErrors:
    """Tests for ERROR condition."""

    def test_error_when_remote_exists_but_no_sync_record(self):
        """Returns ERROR when remote path exists but sync record is missing."""
        async def _test():
            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (False, False),  # local doesn't exist
                        (True, True),  # remote exists
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=None,
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=None),  # No sync record
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path="/local/path",
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.ERROR
            assert "remote sync record does not exist" in status.error_message.lower()

        asyncio.run(_test())

    def test_error_when_local_has_record_but_remote_missing(self, tmp_path):
        """Returns ERROR when local has sync record but remote path is missing."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            local_record = MagicMock(spec=SyncRecord)
            local_record.ulid = ULID()
            local_record.sync_complete = True
            local_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists
                        (False, False),  # remote doesn't exist
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[local_record, None]),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.ERROR
            assert "remote path does not exist" in status.error_message.lower()

        asyncio.run(_test())

    def test_error_when_both_exist_but_local_record_missing(self, tmp_path):
        """Returns ERROR when both paths exist but local sync record is missing."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            remote_record = MagicMock(spec=SyncRecord)
            remote_record.ulid = ULID()
            remote_record.sync_complete = True
            remote_record.timestamp = datetime.now(timezone.utc)

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists
                        (True, True),  # remote exists
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(side_effect=[None, remote_record]),  # No local record
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.sync_condition == SyncCondition.ERROR
            assert "local sync record does not exist" in status.error_message.lower()

        asyncio.run(_test())


# ============================================================================
# Tests for file type mismatch
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 11
class TestGetSyncStatusTypeMismatch:
    """Tests for file/directory type mismatch."""

    def test_raises_when_local_is_file_remote_is_dir(self):
        """Raises exception when local is file but remote is directory."""
        async def _test():
            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, False),  # local exists, is file
                        (True, True),  # remote exists, is dir
                    ]),
                ),
            ):
                with pytest.raises(Exception, match="not both files or both directories"):
                    await get_sync_status(
                        rclone_config_path="/config",
                        local_path="/local/path",
                        local_sync_record_path="/local/.sync",
                        remote="myremote",
                        remote_path="/remote/path",
                        remote_sync_record_path="/remote/.sync",
                    )

        asyncio.run(_test())

    def test_raises_when_local_is_dir_remote_is_file(self, tmp_path):
        """Raises exception when local is directory but remote is file."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (True, False),  # remote exists, is file
                    ]),
                ),
            ):
                with pytest.raises(Exception, match="not both files or both directories"):
                    await get_sync_status(
                        rclone_config_path="/config",
                        local_path=local_dir,
                        local_sync_record_path="/local/.sync",
                        remote="myremote",
                        remote_path="/remote/path",
                        remote_sync_record_path="/remote/.sync",
                    )

        asyncio.run(_test())


# ============================================================================
# Tests for return value structure
# ============================================================================

# %% pts/tests/unit/models/test_get_sync_status.pct.py 12
class TestGetSyncStatusReturnValue:
    """Tests for get_sync_status return value structure."""

    def test_returns_sync_status_namedtuple(self):
        """get_sync_status returns a SyncStatus namedtuple."""
        async def _test():
            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(return_value=(False, False)),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=None),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path="/local/path",
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert isinstance(status, SyncStatus)
            assert hasattr(status, "sync_condition")
            assert hasattr(status, "local_path_exists")
            assert hasattr(status, "remote_path_exists")
            assert hasattr(status, "local_sync_record")
            assert hasattr(status, "remote_sync_record")
            assert hasattr(status, "is_dir")

        asyncio.run(_test())

    def test_is_dir_reflects_path_type(self, tmp_path):
        """is_dir field correctly reflects whether paths are directories."""
        async def _test():
            local_dir = tmp_path / "local_box"
            local_dir.mkdir()

            with (
                patch(
                    "boxyard._utils.rclone_path_exists",
                    new=AsyncMock(side_effect=[
                        (True, True),  # local exists, is dir
                        (False, False),  # remote doesn't exist
                    ]),
                ),
                patch(
                    "boxyard._utils.check_last_time_modified",
                    return_value=datetime.now(timezone.utc),
                ),
                patch.object(
                    SyncRecord,
                    "rclone_read",
                    new=AsyncMock(return_value=None),
                ),
            ):
                status = await get_sync_status(
                    rclone_config_path="/config",
                    local_path=local_dir,
                    local_sync_record_path="/local/.sync",
                    remote="myremote",
                    remote_path="/remote/path",
                    remote_sync_record_path="/remote/.sync",
                )

            assert status.is_dir is True

        asyncio.run(_test())
