# AUTOGENERATED! DO NOT EDIT! File to edit: pts/mod/config.pct.py

__all__ = [
    "BoxGroupConfig",
    "BoxGroupTitleMode",
    "BoxTimestampFormat",
    "Config",
    "StorageConfig",
    "StorageType",
    "VirtualBoxGroupConfig",
    "get_config",
]

# %% pts/mod/config.pct.py 3
from pydantic import model_validator
from pathlib import Path
import toml
from enum import Enum

from . import const


# %% pts/mod/config.pct.py 5
class StorageType(Enum):
    RCLONE = "rclone"
    LOCAL = "local"


class StorageConfig(const.StrictModel):
    storage_type: StorageType
    store_path: Path

    @model_validator(mode="after")
    def validate_config(self):
        # Expand paths
        self.store_path = self.store_path.expanduser()
        return self


class BoxGroupTitleMode(Enum):
    INDEX_NAME = "index_name"
    DATETIME_AND_NAME = "datetime_and_name"
    NAME = "name"


class BoxGroupConfig(const.StrictModel):
    symlink_name: str | None = None
    box_title_mode: BoxGroupTitleMode = BoxGroupTitleMode.INDEX_NAME
    unique_box_names: bool = False


class VirtualBoxGroupConfig(const.StrictModel):
    symlink_name: str | None = None
    box_title_mode: BoxGroupTitleMode = BoxGroupTitleMode.INDEX_NAME
    filter_expr: str

    def is_in_group(self, groups: list[str]) -> bool:
        if not hasattr(self, "_filter_func"):
            from ._utils.logical_expressions import get_group_filter_func

            self._filter_func = get_group_filter_func(self.filter_expr)
        return self._filter_func(groups)


class BoxTimestampFormat(Enum):
    DATE_AND_TIME = "date_and_time"
    DATE_ONLY = "date_only"


class Config(const.StrictModel):
    config_path: Path  # Path to the config file. Will not be saved to the config file.

    default_storage_location: str
    boxyard_data_path: Path
    box_timestamp_format: BoxTimestampFormat
    user_boxes_path: Path
    user_box_groups_path: Path
    storage_locations: dict[str, StorageConfig]
    box_groups: dict[str, BoxGroupConfig]
    virtual_box_groups: dict[str, VirtualBoxGroupConfig]
    default_box_groups: list[str]
    box_subid_character_set: str
    box_subid_length: int
    max_concurrent_rclone_ops: int

    # New box creation settings
    sync_before_new_box: bool = (
        False  # If True, sync boxmetas before creating new box to check for ID collisions on remote
    )

    @property
    def local_store_path(self) -> Path:
        return self.boxyard_data_path / "local_store"

    @property
    def local_sync_backups_path(self) -> Path:
        return self.boxyard_data_path / "sync_backups"

    @property
    def boxyard_meta_path(self) -> Path:
        return self.boxyard_data_path / "boxyard_meta.json"

    @property
    def rclone_config_path(self) -> Path:
        return Path(self.config_path).parent / "boxyard_rclone.conf"

    @property
    def default_rclone_exclude_path(self) -> Path:
        return self.config_path.parent / "default.rclone_exclude"

    @property
    def remote_indexes_path(self) -> Path:
        """Path to cached remote index lookups (box_id -> remote index_name)."""
        return self.boxyard_data_path / "remote_indexes"

    @model_validator(mode="after")
    def validate_config(self):
        # Expand all paths
        self.config_path = Path(self.config_path).expanduser()
        self.boxyard_data_path = Path(self.boxyard_data_path).expanduser()
        self.user_boxes_path = Path(self.user_boxes_path).expanduser()
        self.user_box_groups_path = Path(self.user_box_groups_path).expanduser()

        import re

        for name in self.storage_locations.keys():
            if not re.fullmatch(r"[A-Za-z0-9_-]+", name):
                raise ValueError(
                    f"StorageConfig name {name} is invalid. StorageConfig names can only contain alphanumeric characters, underscore(_), or dash(-)."
                )

        if len(self.storage_locations) == 0:
            raise ValueError("No storage locations defined.")

        # Check that the default storage location exists
        if not any(name == self.default_storage_location for name in self.storage_locations):
            raise ValueError(
                f"default_storage_location '{self.default_storage_location}' not found in storage_locations"
            )

        from ._models import BoxMeta

        for group_name in list(self.box_groups.keys()) + list(self.virtual_box_groups.keys()):
            BoxMeta.validate_group_name(group_name)

        return self


# %% pts/mod/config.pct.py 6
def get_config(path: Path | None = None) -> Config:
    if path is None:
        path = const.DEFAULT_CONFIG_PATH
    path = Path(path).expanduser()
    return Config(**{"config_path": path, **toml.load(path)})


# %% pts/mod/config.pct.py 7
def _get_default_config_dict(config_path=None, data_path=None) -> Config:
    if config_path is None:
        config_path = const.DEFAULT_CONFIG_PATH
    if data_path is None:
        data_path = const.DEFAULT_DATA_PATH
    config_path = Path(config_path)
    data_path = Path(data_path)

    config_dict = dict(
        config_path=config_path.as_posix(),
        default_storage_location="fake",
        boxyard_data_path=data_path.as_posix(),
        box_timestamp_format=BoxTimestampFormat.DATE_ONLY.value,
        user_boxes_path=const.DEFAULT_USER_BOXES_PATH.as_posix(),
        user_box_groups_path=const.DEFAULT_USER_BOX_GROUPS_PATH.as_posix(),
        storage_locations={
            "fake": dict(
                storage_type=StorageType.LOCAL.value,
                store_path=(data_path / const.DEFAULT_FAKE_STORE_REL_PATH).as_posix(),
            )
        },
        box_groups={},
        virtual_box_groups={},
        default_box_groups=[],
        box_subid_character_set=const.DEFAULT_BOX_SUBID_CHARACTER_SET,
        box_subid_length=const.DEFAULT_BOX_SUBID_LENGTH,
        max_concurrent_rclone_ops=const.DEFAULT_MAX_CONCURRENT_RCLONE_OPS,
        sync_before_new_box=False,
    )
    return config_dict


# %% pts/mod/config.pct.py 9
_default_rclone_config = """
"""
