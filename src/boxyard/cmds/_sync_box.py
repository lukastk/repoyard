# AUTOGENERATED! DO NOT EDIT!

from pathlib import Path
import asyncio

from .._utils.sync_helper import sync_helper, SyncSetting, SyncDirection
from .._models import SyncStatus, BoxPart, BoxMeta, SyncCondition
from ..config import get_config, StorageType
from .._utils import (
    check_interrupted,
    enable_soft_interruption,
    SoftInterruption,
)
from .._utils.locking import BoxyardLockManager, LockAcquisitionError, REPO_SYNC_LOCK_TIMEOUT, acquire_lock_async
from .. import const
from .._tombstones import is_tombstoned, get_tombstone
from .._remote_index import find_remote_box_by_id, update_remote_index_cache


async def sync_box(
    config_path: Path,
    box_index_name: str,
    sync_direction: SyncDirection | None = None,
    sync_setting: SyncSetting = SyncSetting.CAREFUL,
    sync_choices: list[BoxPart] | None = None,
    verbose: bool = False,
    show_rclone_progress: bool = False,
    soft_interruption_enabled: bool = True,
    _skip_lock: bool = False,
) -> dict[BoxPart, tuple[SyncStatus, bool]]:
    """
    Syncs a box with its remote.

    Args:
        config_path: Path to the boxyard config file.
        box_index_name: Full name of the box to sync.
        sync_direction: Direction of sync.
        sync_setting: SyncSetting option (SAFE, CAREFUL, FORCE).
        sync_choices: List of BoxPart specifying what to sync. If None, all parts are synced.
        force: Force syncing, possibly overwriting changes.
        verbose: Print verbose output during sync.
        show_rclone_progress: Show rclone progress during sync.
    """
    config = get_config(config_path)
    if sync_choices is None:
        sync_choices = [box_part for box_part in BoxPart]

    if soft_interruption_enabled:
        enable_soft_interruption()
    from boxyard._models import get_boxyard_meta

    boxyard_meta = get_boxyard_meta(config)

    if box_index_name not in boxyard_meta.by_index_name:
        raise ValueError(f"Box '{box_index_name}' not found.")

    box_meta = boxyard_meta.by_index_name[box_index_name]
    if box_meta.get_storage_location_config(config).storage_type == StorageType.LOCAL:
        pass
        return
    box_id = BoxMeta.extract_box_id(box_index_name)
    storage_location = box_meta.storage_location

    _is_tombstoned = await is_tombstoned(config, storage_location, box_id)
    if _is_tombstoned:
        _tombstone = await get_tombstone(config, storage_location, box_id)
        _tombstone_msg = f"Box '{box_index_name}' was deleted"
        if _tombstone:
            _tombstone_msg += f" by {_tombstone.deleted_by_hostname} at {_tombstone.deleted_at_utc}"
        print(f"Warning: {_tombstone_msg}. Skipping sync.")
        from boxyard._models import SyncRecord

        _dummy_sync_record = SyncRecord.create(sync_complete=False)
        sync_results = {
            part: (
                SyncStatus(
                    sync_condition=SyncCondition.TOMBSTONED,
                    local_path_exists=False,
                    remote_path_exists=False,
                    local_sync_record=_dummy_sync_record,
                    remote_sync_record=_dummy_sync_record,
                    is_dir=True,
                    error_message=_tombstone_msg,
                ),
                False,
            )
            for part in sync_choices
        }
        return sync_results
    remote_index_name = await find_remote_box_by_id(config, storage_location, box_id)

    # If remote doesn't exist, this is a new box - use local index_name for remote
    # If remote exists with different name, use that name for remote paths
    if remote_index_name is None:
        remote_index_name = box_index_name

    # Precompute remote paths using the remote_index_name (which may differ from local)
    def _get_remote_path_for_index(idx_name: str) -> Path:
        return config.storage_locations[storage_location].store_path / const.REMOTE_BOXES_REL_PATH / idx_name

    def _get_remote_part_path_for_index(idx_name: str, part: BoxPart) -> Path:
        base = _get_remote_path_for_index(idx_name)
        if part == BoxPart.DATA:
            return base / const.BOX_DATA_REL_PATH
        elif part == BoxPart.META:
            return base / const.BOX_METAFILE_REL_PATH
        elif part == BoxPart.CONF:
            return base / const.BOX_CONF_REL_PATH
        raise ValueError(f"Invalid box part: {part}")

    def _get_remote_sync_record_path_for_index(idx_name: str, part: BoxPart) -> Path:
        sl_conf = config.storage_locations[storage_location]
        return sl_conf.store_path / const.SYNC_RECORDS_REL_PATH / idx_name / f"{part.value}.rec"

    _sync_lock = None
    if not _skip_lock:
        _lock_manager = BoxyardLockManager(config.boxyard_data_path)
        _lock_path = _lock_manager.box_sync_lock_path(box_index_name)
        _lock_manager._ensure_lock_dir(_lock_path)
        _sync_lock = __import__("filelock").FileLock(_lock_path, timeout=0)
        await acquire_lock_async(
            _sync_lock,
            f"box sync ({box_index_name})",
            _lock_path,
            REPO_SYNC_LOCK_TIMEOUT,
        )

    try:
        # Prints
        if verbose:
            print(f"Syncing box {box_index_name} at {box_meta.storage_location}.")

        # Get the backup locations
        sl_config = box_meta.get_storage_location_config(config)
        local_sync_backups_path = config.local_sync_backups_path
        remote_sync_backups_path = sl_config.store_path / const.REMOTE_BACKUP_REL_PATH

        # Sync the boxmeta
        sync_results = {}

        if check_interrupted():
            raise SoftInterruption()

        sync_part = BoxPart.META
        if sync_part in sync_choices:
            if verbose:
                print(f"Syncing {sync_part.value}.")
            sync_results[BoxPart.META] = await sync_helper(
                rclone_config_path=config.rclone_config_path,
                sync_direction=sync_direction,
                sync_setting=sync_setting,
                local_path=box_meta.get_local_part_path(config, BoxPart.META),
                local_sync_record_path=box_meta.get_local_sync_record_path(config, sync_part),
                remote=box_meta.storage_location,
                remote_path=_get_remote_part_path_for_index(remote_index_name, BoxPart.META),
                remote_sync_record_path=_get_remote_sync_record_path_for_index(remote_index_name, sync_part),
                local_sync_backups_path=local_sync_backups_path,
                remote_sync_backups_path=remote_sync_backups_path,
                verbose=verbose,
                show_rclone_progress=show_rclone_progress,
            )

        # Sync the boxconf
        if check_interrupted():
            raise SoftInterruption()

        sync_part = BoxPart.CONF
        if sync_part in sync_choices:
            if verbose:
                print("Syncing", sync_part.value)
            sync_results[sync_part] = await sync_helper(
                rclone_config_path=config.rclone_config_path,
                sync_direction=sync_direction,
                sync_setting=sync_setting,
                local_path=box_meta.get_local_part_path(config, BoxPart.CONF),
                local_sync_record_path=box_meta.get_local_sync_record_path(config, sync_part),
                remote=box_meta.storage_location,
                remote_path=_get_remote_part_path_for_index(remote_index_name, BoxPart.CONF),
                remote_sync_record_path=_get_remote_sync_record_path_for_index(remote_index_name, sync_part),
                local_sync_backups_path=local_sync_backups_path,
                remote_sync_backups_path=remote_sync_backups_path,
                verbose=verbose,
                show_rclone_progress=show_rclone_progress,
                allow_missing_source=True,  # CONF is optional - may not exist on either side
            )

        # Get the now locally synced conf files for the sync of the box data
        _rclone_include_path = box_meta.get_local_part_path(config, BoxPart.CONF) / ".rclone_include"
        _rclone_exclude_path = box_meta.get_local_part_path(config, BoxPart.CONF) / ".rclone_exclude"
        _rclone_filters_path = box_meta.get_local_part_path(config, BoxPart.CONF) / ".rclone_filters"

        _rclone_include_path = _rclone_include_path if _rclone_include_path.exists() else None
        _rclone_exclude_path = (
            _rclone_exclude_path if _rclone_exclude_path.exists() else config.default_rclone_exclude_path
        )
        _rclone_filters_path = _rclone_filters_path if _rclone_filters_path.exists() else None

        # Sync the box data
        if check_interrupted():
            raise SoftInterruption()

        sync_part = BoxPart.DATA
        if sync_part in sync_choices:
            if verbose:
                print("Syncing", sync_part.value)
            sync_results[sync_part] = await sync_helper(
                rclone_config_path=config.rclone_config_path,
                sync_direction=sync_direction,
                sync_setting=sync_setting,
                local_path=box_meta.get_local_part_path(config, BoxPart.DATA),
                local_sync_record_path=box_meta.get_local_sync_record_path(config, sync_part),
                remote=box_meta.storage_location,
                remote_path=_get_remote_part_path_for_index(remote_index_name, BoxPart.DATA),
                remote_sync_record_path=_get_remote_sync_record_path_for_index(remote_index_name, sync_part),
                local_sync_backups_path=local_sync_backups_path,
                remote_sync_backups_path=remote_sync_backups_path,
                include_path=_rclone_include_path,
                exclude_path=_rclone_exclude_path,
                filters_path=_rclone_filters_path,
                verbose=verbose,
                show_rclone_progress=show_rclone_progress,
            )

        # Update remote index cache
        update_remote_index_cache(config, storage_location, box_id, remote_index_name)

        # Refresh the boxyard meta file
        if BoxPart.META in sync_choices:
            from boxyard._models import refresh_boxyard_meta

            refresh_boxyard_meta(config)
    finally:
        if _sync_lock is not None:
            _sync_lock.release()
    return sync_results
