# AUTOGENERATED! DO NOT EDIT! File to edit: pts/mod/_fast.pct.py

__all__ = ['BoxyardFast']

# %% pts/mod/_fast.pct.py 3
import json
from pathlib import Path
from collections import deque


class BoxyardFast:
    """Lightweight, stdlib-only query interface for boxyard metadata.

    Reads the boxyard_meta.json file and provides fast lookups for
    parent-child relationships, groups, and DAG traversal without
    importing any boxyard modules.
    """

    def __init__(self, data: dict):
        box_metas = data.get("box_metas", [])
        self._boxes = box_metas
        self._by_id: dict[str, dict] = {}
        self._children_index: dict[str, list[str]] = {}

        for bm in box_metas:
            ts = bm["creation_timestamp_utc"]
            subid = bm["box_subid"]
            box_id = f"{ts}_{subid}"
            bm["_box_id"] = box_id
            bm["_index_name"] = f"{box_id}__{bm['name']}"
            self._by_id[box_id] = bm

        # Build children index from parents
        for bm in box_metas:
            for parent_id in bm.get("parents", []):
                self._children_index.setdefault(parent_id, []).append(bm["_box_id"])

    @classmethod
    def from_file(cls, path: str | Path | None = None) -> "BoxyardFast":
        if path is None:
            path = Path.home() / ".boxyard" / "boxyard_meta.json"
        path = Path(path)
        data = json.loads(path.read_text())
        return cls(data)

    # ── helpers ──

    def _filter_by_groups(self, boxes: list[dict], groups: set[str] | None) -> list[dict]:
        if groups is None:
            return boxes
        return [b for b in boxes if set(b.get("groups", [])) & groups]

    def _to_result(self, bm: dict) -> dict:
        return {
            "name": bm["name"],
            "box_id": bm["_box_id"],
            "index_name": bm["_index_name"],
            "groups": bm.get("groups", []),
            "parents": bm.get("parents", []),
            "storage_location": bm.get("storage_location", ""),
        }

    # ── parent-child queries ──

    def children_of(self, box_id: str, groups: set[str] | None = None) -> list[dict]:
        child_ids = self._children_index.get(box_id, [])
        children = [self._by_id[cid] for cid in child_ids if cid in self._by_id]
        return [self._to_result(c) for c in self._filter_by_groups(children, groups)]

    def descendants_of(self, box_id: str, groups: set[str] | None = None) -> list[dict]:
        visited: set[str] = set()
        queue = deque([box_id])
        result = []
        while queue:
            current = queue.popleft()
            for child_id in self._children_index.get(current, []):
                if child_id not in visited and child_id in self._by_id:
                    visited.add(child_id)
                    result.append(self._by_id[child_id])
                    queue.append(child_id)
        return [self._to_result(r) for r in self._filter_by_groups(result, groups)]

    def parents_of(self, box_id: str, groups: set[str] | None = None) -> list[dict]:
        bm = self._by_id.get(box_id)
        if bm is None:
            return []
        parent_boxes = [self._by_id[pid] for pid in bm.get("parents", []) if pid in self._by_id]
        return [self._to_result(p) for p in self._filter_by_groups(parent_boxes, groups)]

    def ancestors_of(self, box_id: str, groups: set[str] | None = None) -> list[dict]:
        visited: set[str] = set()
        queue = deque([box_id])
        result = []
        while queue:
            current = queue.popleft()
            bm = self._by_id.get(current)
            if bm is None:
                continue
            for parent_id in bm.get("parents", []):
                if parent_id not in visited and parent_id in self._by_id:
                    visited.add(parent_id)
                    result.append(self._by_id[parent_id])
                    queue.append(parent_id)
        return [self._to_result(r) for r in self._filter_by_groups(result, groups)]

    def roots(self, groups: set[str] | None = None) -> list[dict]:
        root_boxes = [bm for bm in self._boxes if len(bm.get("parents", [])) == 0]
        return [self._to_result(r) for r in self._filter_by_groups(root_boxes, groups)]

    def leaves(self, groups: set[str] | None = None) -> list[dict]:
        all_parent_ids: set[str] = set()
        for bm in self._boxes:
            all_parent_ids.update(bm.get("parents", []))
        leaf_boxes = [bm for bm in self._boxes if bm["_box_id"] not in all_parent_ids]
        return [self._to_result(r) for r in self._filter_by_groups(leaf_boxes, groups)]

    def is_ancestor(self, box_id: str, potential_ancestor_id: str) -> bool:
        ancestors = self.ancestors_of(box_id)
        return any(a["box_id"] == potential_ancestor_id for a in ancestors)

    def is_descendant(self, box_id: str, potential_descendant_id: str) -> bool:
        descendants = self.descendants_of(box_id)
        return any(d["box_id"] == potential_descendant_id for d in descendants)

    def has_cycle(self) -> bool:
        # Kahn's algorithm for topological sort — cycle exists if not all nodes processed
        in_degree: dict[str, int] = {bid: 0 for bid in self._by_id}
        for bm in self._boxes:
            for parent_id in bm.get("parents", []):
                if parent_id in in_degree:
                    in_degree[bm["_box_id"]] = in_degree.get(bm["_box_id"], 0) + 1

        # Recalculate properly: in_degree counts how many parents each node has (within known set)
        in_degree = {bid: 0 for bid in self._by_id}
        for bm in self._boxes:
            for parent_id in bm.get("parents", []):
                if parent_id in self._by_id:
                    in_degree[bm["_box_id"]] += 1

        queue = deque([bid for bid, deg in in_degree.items() if deg == 0])
        processed = 0
        while queue:
            node = queue.popleft()
            processed += 1
            for child_id in self._children_index.get(node, []):
                if child_id in in_degree:
                    in_degree[child_id] -= 1
                    if in_degree[child_id] == 0:
                        queue.append(child_id)
        return processed != len(self._by_id)

    def would_create_cycle(self, child_id: str, proposed_parent_id: str) -> bool:
        if child_id == proposed_parent_id:
            return True
        return self.is_ancestor(proposed_parent_id, child_id)

    # ── DAG representation ──

    def get_dag(self) -> dict:
        result = {}
        for bm in self._boxes:
            box_id = bm["_box_id"]
            result[box_id] = {
                "name": bm["name"],
                "index_name": bm["_index_name"],
                "box_id": box_id,
                "groups": bm.get("groups", []),
                "parents": bm.get("parents", []),
                "children": self._children_index.get(box_id, []),
            }
        return result

    def get_dag_nested(self, root_id: str | None = None) -> dict:
        def _build_subtree(box_id: str, visited: set[str]) -> dict | None:
            if box_id in visited or box_id not in self._by_id:
                return None
            visited.add(box_id)
            bm = self._by_id[box_id]
            children = {}
            for child_id in self._children_index.get(box_id, []):
                child_tree = _build_subtree(child_id, visited)
                if child_tree is not None:
                    children[child_id] = child_tree
            return {
                "name": bm["name"],
                "index_name": bm["_index_name"],
                "box_id": box_id,
                "groups": bm.get("groups", []),
                "children": children,
            }

        if root_id is not None:
            visited: set[str] = set()
            tree = _build_subtree(root_id, visited)
            return {root_id: tree} if tree else {}

        # Build from all roots
        visited: set[str] = set()
        result = {}
        for bm in self._boxes:
            if len(bm.get("parents", [])) == 0:
                tree = _build_subtree(bm["_box_id"], visited)
                if tree is not None:
                    result[bm["_box_id"]] = tree
        return result

    # ── group queries ──

    def groups_of(self, box_id: str) -> list[str]:
        bm = self._by_id.get(box_id)
        if bm is None:
            return []
        return list(bm.get("groups", []))

    def boxes_by_group(self, group_name: str) -> list[dict]:
        return [self._to_result(bm) for bm in self._boxes if group_name in bm.get("groups", [])]

    def all_boxes_with_groups(self) -> dict[str, list[str]]:
        return {bm["_index_name"]: list(bm.get("groups", [])) for bm in self._boxes}

    def all_groups(self) -> list[str]:
        groups: set[str] = set()
        for bm in self._boxes:
            groups.update(bm.get("groups", []))
        return sorted(groups)

    # ── path-based queries ──

    def which(self, path: str, user_boxes_path: str = "~/boxes") -> dict | None:
        """Resolve a filesystem path to the box it belongs to.

        Mirrors the CLI ``which`` command: checks whether *path* falls under
        *user_boxes_path* and, if so, extracts the first directory component
        as the index_name and returns the matching box result dict.

        Returns ``None`` when the path is outside the boxes directory or when
        no matching box is found in the metadata.
        """
        resolved = Path(path).expanduser().resolve()
        boxes_root = Path(user_boxes_path).expanduser().resolve()

        if not resolved.is_relative_to(boxes_root) or resolved == boxes_root:
            return None

        index_name = resolved.relative_to(boxes_root).parts[0]

        for bm in self._boxes:
            if bm["_index_name"] == index_name:
                return self._to_result(bm)
        return None
