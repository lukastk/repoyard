# AUTOGENERATED! DO NOT EDIT!

from pathlib import Path
import textwrap
from .._utils import check_interrupted, SoftInterruption
from .._enums import SyncSetting, SyncDirection

from .. import const

from .._models import SyncStatus


class SyncFailed(Exception):
    pass


class SyncUnsafe(Exception):
    pass


class InvalidRemotePath(Exception):
    pass


async def sync_helper(
    rclone_config_path: str,
    sync_direction: SyncDirection | None,  # None = auto
    sync_setting: SyncSetting,
    local_path: str,
    local_sync_record_path: str,
    remote: str,
    remote_path: str,
    remote_sync_record_path: str,
    local_sync_backups_path: str,
    remote_sync_backups_path: str,
    include_path: Path | None = None,
    exclude_path: Path | None = None,
    filters_path: Path | None = None,
    include: list[str] | None = None,
    exclude: list[str] | None = None,
    filter: list[str] | None = None,
    delete_backup: bool = True,
    syncer_hostname: str | None = None,
    verbose: bool = False,
    show_rclone_progress: bool = False,
    allow_missing_source: bool = False,
) -> tuple[SyncStatus, bool]:
    """
    Helper to execute the standard routine for syncing a local and remote folder.

    Returns a tuple of the sync status and a boolean indicating if the sync took place.
    """
    if not remote_path:
        raise InvalidRemotePath(
            "Remote path cannot be empty."
        )  # Disqualifying empty remote paths as it can cause issues with the safety mechanisms
    if sync_direction is None and sync_setting != SyncSetting.CAREFUL:
        raise ValueError("Auto sync direction can only be used with careful sync setting.")
    from boxyard._models import get_sync_status, SyncCondition

    sync_status = await get_sync_status(
        rclone_config_path=rclone_config_path,
        local_path=local_path,
        local_sync_record_path=local_sync_record_path,
        remote=remote,
        remote_path=remote_path,
        remote_sync_record_path=remote_sync_record_path,
    )
    (
        sync_condition,
        local_path_exists,
        remote_path_exists,
        local_sync_record,
        remote_sync_record,
        sync_path_is_dir,
        error_message,
    ) = sync_status

    if sync_condition == SyncCondition.ERROR and sync_setting != SyncSetting.FORCE:
        raise Exception(error_message)

    def _can_safely_retry_incomplete(sync_cond, sync_dir, local_rec, remote_rec):
        """Check if this machine can safely retry an incomplete sync.

        For SYNC_FROM_REMOTE_INCOMPLETE (pull was interrupted):
            - Local is incomplete, this machine owns it
            - Safe to retry pull

        For SYNC_TO_REMOTE_INCOMPLETE (push was interrupted):
            - Remote is incomplete
            - Only safe if this machine started it (matching incomplete ULIDs on both sides)
        """
        if sync_cond == SyncCondition.SYNC_FROM_REMOTE_INCOMPLETE:
            # Local is incomplete - this machine owns it
            # Safe to retry pull (or auto-direction which will choose pull)
            return sync_dir in (SyncDirection.PULL, None)

        if sync_cond == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE:
            # Remote is incomplete - only safe if this machine started it
            if (
                local_rec
                and remote_rec
                and not local_rec.sync_complete
                and not remote_rec.sync_complete
                and local_rec.ulid == remote_rec.ulid
            ):
                # Matching incomplete ULIDs = this machine started it
                return sync_dir in (SyncDirection.PUSH, None)

        return False

    def _raise_unsafe(message=None):
        if message:
            raise SyncUnsafe(message)
        raise SyncUnsafe(
            textwrap.dedent(f"""
            Sync is unsafe. Info:
                Local exists: {local_path_exists}
                Remote exists: {remote_path_exists}
                Local sync record: {local_sync_record}
                Remote sync record: {remote_sync_record}
                Sync condition: {sync_condition.value}
        """).strip()
        )

    if sync_setting != SyncSetting.FORCE and sync_condition == SyncCondition.SYNCED:
        if verbose:
            print("Sync not needed.")
        return sync_status, False

    if sync_direction is None:  # auto
        if sync_condition == SyncCondition.NEEDS_PUSH:
            sync_direction = SyncDirection.PUSH
        elif sync_condition == SyncCondition.NEEDS_PULL:
            sync_direction = SyncDirection.PULL
        elif sync_condition == SyncCondition.EXCLUDED:
            if verbose:
                print("Sync not needed as the box is excluded.")
            return sync_status, False
        elif sync_condition == SyncCondition.SYNC_FROM_REMOTE_INCOMPLETE:
            # Local is incomplete from interrupted pull - this machine can safely retry pull
            if _can_safely_retry_incomplete(sync_condition, SyncDirection.PULL, local_sync_record, remote_sync_record):
                sync_direction = SyncDirection.PULL
            else:
                _raise_unsafe()
        elif sync_condition == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE:
            # Remote is incomplete from interrupted push
            # Only safe to retry if this machine started it (matching incomplete ULIDs)
            if _can_safely_retry_incomplete(sync_condition, SyncDirection.PUSH, local_sync_record, remote_sync_record):
                sync_direction = SyncDirection.PUSH
            else:
                _raise_unsafe(
                    "Remote has an incomplete sync from another machine. "
                    "Use --sync-setting force to override, or sync from the original machine."
                )
        else:
            _raise_unsafe()  # In the case where the sync status is SYNCED, 'auto'-mode should not reach this, as it should have already returned (as auto can only be used in CAREFUL mode)

    if sync_setting == SyncSetting.CAREFUL:
        if sync_direction == SyncDirection.PUSH:
            if sync_condition in [SyncCondition.NEEDS_PUSH, SyncCondition.SYNCED]:
                pass  # Safe to push
            elif sync_condition == SyncCondition.SYNC_TO_REMOTE_INCOMPLETE:
                # Check if this machine can safely retry the interrupted push
                if not _can_safely_retry_incomplete(
                    sync_condition, sync_direction, local_sync_record, remote_sync_record
                ):
                    _raise_unsafe(
                        "Remote has an incomplete sync from another machine. "
                        "Use --sync-setting force to override, or sync from the original machine."
                    )
            else:
                _raise_unsafe()
        elif sync_direction == SyncDirection.PULL:
            if sync_condition in [SyncCondition.NEEDS_PULL, SyncCondition.SYNCED]:
                pass  # Safe to pull
            elif sync_condition == SyncCondition.SYNC_FROM_REMOTE_INCOMPLETE:
                # Local is incomplete from interrupted pull - this machine can safely retry
                if not _can_safely_retry_incomplete(
                    sync_condition, sync_direction, local_sync_record, remote_sync_record
                ):
                    _raise_unsafe()  # This shouldn't happen, but just in case
            else:
                _raise_unsafe()
    # If source doesn't exist and we allow missing source, return early
    if allow_missing_source:
        source_exists = remote_path_exists if sync_direction == SyncDirection.PULL else local_path_exists
        if not source_exists:
            if verbose:
                print(f"Source does not exist and allow_missing_source=True. Skipping sync.")
            return sync_status, False
    from boxyard._utils import rclone_sync, BisyncResult, rclone_mkdir, rclone_purge

    async def _sync(
        dry_run: bool,
        source: str,
        source_path: str,
        dest: str,
        dest_path: str,
        backup_remote: str,
        backup_path: str,
        return_command: bool = False,
    ) -> BisyncResult:
        if not sync_path_is_dir:
            dest_path = Path(
                dest_path
            ).parent.as_posix()  # needed because rlcone sync doesn't seem to accept files on the dest path
            if dest_path == ".":
                dest_path = ""

        if verbose:
            print(f"Syncing {source}:{source_path} to {dest}:{dest_path}.  Backup path: {backup_remote}:{backup_path}")

        # Create backup store directory if it doesn't already exist
        await rclone_mkdir(
            rclone_config_path=rclone_config_path,
            source=backup_remote,
            source_path=backup_path,
        )

        return await rclone_sync(
            rclone_config_path=rclone_config_path,
            source=source,
            source_path=source_path,
            dest=dest,
            dest_path=dest_path,
            include=include or [],
            exclude=exclude or [],
            filter=filter or [],
            include_file=include_path,
            exclude_file=exclude_path,
            filters_file=filters_path,
            backup_path=f"{backup_remote}:{backup_path}" if backup_remote else backup_path,
            dry_run=dry_run,
            return_command=return_command,
            verbose=False,
            progress=show_rclone_progress,
        )

    from boxyard._models import SyncRecord

    if check_interrupted():
        raise SoftInterruption()

    rec = SyncRecord.create(syncer_hostname=syncer_hostname, sync_complete=False)
    backup_name = str(rec.ulid)

    if sync_direction == SyncDirection.PULL:
        # Save the sync record on local to signify an ongoing sync
        await rec.rclone_save(rclone_config_path, "", local_sync_record_path)

        backup_remote = ""
        backup_path = Path(local_sync_backups_path) / backup_name

        res, stdout, stderr = await _sync(
            dry_run=False,
            source=remote,
            source_path=remote_path,
            dest="",
            dest_path=local_path,
            backup_remote=backup_remote,
            backup_path=backup_path,
        )

        if res:
            # Retrieve the remote sync record and save it locally
            rec = await SyncRecord.rclone_read(rclone_config_path, remote, remote_sync_record_path)
            await rec.rclone_save(rclone_config_path, "", local_sync_record_path)

    elif sync_direction == SyncDirection.PUSH:
        # Save the incomplete sync record on BOTH local and remote to signify an ongoing sync
        # This creates a "sync session" marker - if interrupted, both sides have the same incomplete ULID,
        # proving this machine owns the interrupted sync and can safely retry
        await rec.rclone_save(rclone_config_path, remote, remote_sync_record_path)
        await rec.rclone_save(rclone_config_path, "", local_sync_record_path)

        backup_remote = remote
        backup_path = Path(remote_sync_backups_path) / backup_name

        res, stdout, stderr = await _sync(
            dry_run=False,
            source="",
            source_path=local_path,
            dest=remote,
            dest_path=remote_path,
            backup_remote=backup_remote,
            backup_path=backup_path,
        )

        if res:
            # Create a new sync record and save it at the remote
            rec = SyncRecord.create(syncer_hostname=syncer_hostname, sync_complete=True)
            await rec.rclone_save(rclone_config_path, "", local_sync_record_path)
            await rec.rclone_save(rclone_config_path, remote, remote_sync_record_path)

    else:
        raise ValueError(f"Unknown sync direction: {sync_direction}")

    if not res:
        raise SyncFailed(f"Sync failed. Rclone output:\n{stdout}\n{stderr}")

    if res and delete_backup:
        await rclone_purge(
            rclone_config_path=rclone_config_path,
            source=backup_remote,
            source_path=backup_path,
        )
    return sync_status, True
