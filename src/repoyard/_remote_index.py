# AUTOGENERATED! DO NOT EDIT! File to edit: pts/mod/_remote_index.pct.py

__all__ = [
    "find_remote_repo_by_id",
    "get_remote_index_cache_path",
    "load_remote_index_cache",
    "remove_from_remote_index_cache",
    "save_remote_index_cache",
    "scan_and_rebuild_remote_index_cache",
    "update_remote_index_cache",
]

# %% pts/mod/_remote_index.pct.py 3
import json
from pathlib import Path

import repoyard.config

from . import const


# %% pts/mod/_remote_index.pct.py 5
def get_remote_index_cache_path(config: repoyard.config.Config, storage_location: str) -> Path:
    """Get the path to the remote index cache file for a storage location."""
    return config.remote_indexes_path / f"{storage_location}.json"


# %% pts/mod/_remote_index.pct.py 6
def load_remote_index_cache(config: repoyard.config.Config, storage_location: str) -> dict[str, str]:
    """
    Load the remote index cache for a storage location.

    Returns:
        Dict mapping repo_id -> remote index_name
    """
    cache_path = get_remote_index_cache_path(config, storage_location)
    if cache_path.exists():
        try:
            return json.loads(cache_path.read_text())
        except (OSError, json.JSONDecodeError):
            return {}
    return {}


# %% pts/mod/_remote_index.pct.py 7
def save_remote_index_cache(
    config: repoyard.config.Config,
    storage_location: str,
    cache: dict[str, str],
) -> None:
    """
    Save the remote index cache for a storage location.

    Args:
        config: Repoyard config
        storage_location: Name of the storage location
        cache: Dict mapping repo_id -> remote index_name
    """
    cache_path = get_remote_index_cache_path(config, storage_location)
    cache_path.parent.mkdir(parents=True, exist_ok=True)
    cache_path.write_text(json.dumps(cache, indent=2))


# %% pts/mod/_remote_index.pct.py 8
def update_remote_index_cache(
    config: repoyard.config.Config,
    storage_location: str,
    repo_id: str,
    index_name: str,
) -> None:
    """
    Update a single entry in the remote index cache.

    Args:
        config: Repoyard config
        storage_location: Name of the storage location
        repo_id: The repo ID
        index_name: The remote index_name for this repo
    """
    cache = load_remote_index_cache(config, storage_location)
    cache[repo_id] = index_name
    save_remote_index_cache(config, storage_location, cache)


# %% pts/mod/_remote_index.pct.py 9
def remove_from_remote_index_cache(
    config: repoyard.config.Config,
    storage_location: str,
    repo_id: str,
) -> None:
    """
    Remove an entry from the remote index cache.

    Args:
        config: Repoyard config
        storage_location: Name of the storage location
        repo_id: The repo ID to remove
    """
    cache = load_remote_index_cache(config, storage_location)
    if repo_id in cache:
        del cache[repo_id]
        save_remote_index_cache(config, storage_location, cache)


# %% pts/mod/_remote_index.pct.py 11
async def find_remote_repo_by_id(
    config: repoyard.config.Config,
    storage_location: str,
    repo_id: str,
) -> str | None:
    """
    Find the remote index_name for a given repo_id.

    Uses local cache first, falls back to remote scan if cache miss or stale.

    Args:
        config: Repoyard config
        storage_location: Name of the storage location
        repo_id: The repo ID to find

    Returns:
        The remote index_name if found, None otherwise
    """
    from ._utils.rclone import rclone_lsjson, rclone_path_exists

    sl_config = config.storage_locations[storage_location]
    repos_path = sl_config.store_path / const.REMOTE_REPOS_REL_PATH

    # 1. Check local cache
    cache = load_remote_index_cache(config, storage_location)
    if repo_id in cache:
        cached_index_name = cache[repo_id]
        # Verify it still exists on remote
        repo_path = repos_path / cached_index_name
        exists, _ = await rclone_path_exists(
            rclone_config_path=config.rclone_config_path,
            source=storage_location,
            source_path=repo_path.as_posix(),
        )
        if exists:
            return cached_index_name
        # Cache is stale, remove entry
        del cache[repo_id]
        save_remote_index_cache(config, storage_location, cache)

    # 2. Cache miss or stale - do full scan
    repos = await rclone_lsjson(
        rclone_config_path=config.rclone_config_path,
        source=storage_location,
        source_path=repos_path.as_posix(),
    )

    if repos is not None:
        for item in repos:
            if item.get("IsDir", False) and item.get("Name", "").startswith(f"{repo_id}__"):
                found_index_name = item["Name"]
                # Update cache
                cache[repo_id] = found_index_name
                save_remote_index_cache(config, storage_location, cache)
                return found_index_name

    # 3. Not found - ensure removed from cache
    if repo_id in cache:
        del cache[repo_id]
        save_remote_index_cache(config, storage_location, cache)

    return None


# %% pts/mod/_remote_index.pct.py 12
async def scan_and_rebuild_remote_index_cache(
    config: repoyard.config.Config,
    storage_location: str,
) -> dict[str, str]:
    """
    Scan remote storage and rebuild the entire cache for a storage location.

    Args:
        config: Repoyard config
        storage_location: Name of the storage location

    Returns:
        The rebuilt cache (repo_id -> index_name)
    """
    from ._models import RepoMeta
    from ._utils.rclone import rclone_lsjson

    sl_config = config.storage_locations[storage_location]
    repos_path = sl_config.store_path / const.REMOTE_REPOS_REL_PATH

    repos = await rclone_lsjson(
        rclone_config_path=config.rclone_config_path,
        source=storage_location,
        source_path=repos_path.as_posix(),
    )

    cache = {}
    if repos is not None:
        for item in repos:
            if item.get("IsDir", False):
                index_name = item["Name"]
                try:
                    repo_id = RepoMeta.extract_repo_id(index_name)
                    cache[repo_id] = index_name
                except ValueError:
                    # Invalid index_name format, skip
                    pass

    save_remote_index_cache(config, storage_location, cache)
    return cache
