# AUTOGENERATED! DO NOT EDIT!

from enum import Enum
from pathlib import Path

from .. import const
from .._remote_index import find_remote_repo_by_id, update_remote_index_cache
from .._utils.locking import REPO_SYNC_LOCK_TIMEOUT, RepoyardLockManager, acquire_lock_async
from ..config import StorageType, get_config


class RenameScope(Enum):
    LOCAL = "local"
    REMOTE = "remote"
    BOTH = "both"

async def rename_repo(
    config_path: Path,
    repo_index_name: str,
    new_name: str,
    scope: RenameScope = RenameScope.BOTH,
    verbose: bool = False,
) -> str:
    """
    Rename a repository.

    Args:
        config_path: Path to the repoyard config file.
        repo_index_name: Full index name of the repository to rename.
        new_name: New name for the repository.
        scope: Where to rename - local, remote, or both.
        verbose: Print verbose output.

    Returns:
        The new index name of the repository.

    Note:
        The repo ID (timestamp + subid) remains unchanged.
        Only the name portion of the index_name changes.
    """
    config = get_config(config_path)

    from repoyard._models import RepoMeta, get_repoyard_meta

    repoyard_meta = get_repoyard_meta(config)

    if repo_index_name not in repoyard_meta.by_index_name:
        raise ValueError(f"Repo '{repo_index_name}' not found.")

    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    repo_id = RepoMeta.extract_repo_id(repo_index_name)
    storage_location = repo_meta.storage_location

    # Compute new index name
    new_index_name = f"{repo_id}__{new_name}"

    if verbose:
        print(f"Renaming repo from '{repo_meta.name}' to '{new_name}'")
        print(f"Index name: {repo_index_name} -> {new_index_name}")
    _lock_manager = RepoyardLockManager(config.repoyard_data_path)
    _lock_path = _lock_manager.repo_sync_lock_path(repo_index_name)
    _lock_manager._ensure_lock_dir(_lock_path)
    _sync_lock = __import__('filelock').FileLock(_lock_path, timeout=0)
    await acquire_lock_async(
        _sync_lock,
        f"repo sync ({repo_index_name})",
        _lock_path,
        REPO_SYNC_LOCK_TIMEOUT,
    )

    try:
        # %% [markdown]
        # Rename locally

        # %%
        if scope in (RenameScope.LOCAL, RenameScope.BOTH):
            if verbose:
                print("Renaming locally...")

            # Update the repometa.toml
            repo_meta.name = new_name

            # Compute old and new local paths
            old_local_path = config.local_store_path / storage_location / repo_index_name
            new_local_path = config.local_store_path / storage_location / new_index_name

            old_data_path = config.user_repos_path / repo_index_name
            new_data_path = config.user_repos_path / new_index_name

            old_sync_record_path = config.repoyard_data_path / const.SYNC_RECORDS_REL_PATH / repo_index_name
            new_sync_record_path = config.repoyard_data_path / const.SYNC_RECORDS_REL_PATH / new_index_name

            # Rename directories
            if old_local_path.exists():
                old_local_path.rename(new_local_path)

            if old_data_path.exists():
                old_data_path.rename(new_data_path)

            if old_sync_record_path.exists():
                old_sync_record_path.rename(new_sync_record_path)

            # Save the updated repometa
            repo_meta.save(config)

            if verbose:
                print("Local rename complete.")

        # %% [markdown]
        # Rename on remote

        # %%
        if scope in (RenameScope.REMOTE, RenameScope.BOTH):
            if repo_meta.get_storage_location_config(config).storage_type == StorageType.LOCAL:
                if verbose:
                    print("Skipping remote rename for local storage location.")
            else:
                if verbose:
                    print("Renaming on remote...")

                from repoyard._utils.rclone import rclone_moveto

                sl_config = config.storage_locations[storage_location]
                repos_path = sl_config.store_path / const.REMOTE_REPOS_REL_PATH
                sync_records_path = sl_config.store_path / const.SYNC_RECORDS_REL_PATH

                # Find current remote index name (might differ from local)
                remote_index_name = await find_remote_repo_by_id(config, storage_location, repo_id)

                if remote_index_name is None:
                    if verbose:
                        print("Warning: Remote repo not found. Skipping remote rename.")
                else:
                    # Rename repo directory
                    old_remote_repo_path = repos_path / remote_index_name
                    new_remote_repo_path = repos_path / new_index_name

                    success, error = await rclone_moveto(
                        rclone_config_path=config.rclone_config_path,
                        source=storage_location,
                        source_path=old_remote_repo_path.as_posix(),
                        dest=storage_location,
                        dest_path=new_remote_repo_path.as_posix(),
                    )

                    if not success:
                        raise RuntimeError(f"Failed to rename remote repo: {error}")

                    # Rename sync records directory
                    old_remote_sync_path = sync_records_path / remote_index_name
                    new_remote_sync_path = sync_records_path / new_index_name

                    success, error = await rclone_moveto(
                        rclone_config_path=config.rclone_config_path,
                        source=storage_location,
                        source_path=old_remote_sync_path.as_posix(),
                        dest=storage_location,
                        dest_path=new_remote_sync_path.as_posix(),
                    )

                    # Sync record rename failure is not critical
                    if not success and verbose:
                        print(f"Warning: Failed to rename remote sync records: {error}")

                    # Update remote index cache
                    update_remote_index_cache(config, storage_location, repo_id, new_index_name)

                    if verbose:
                        print("Remote rename complete.")

        # %% [markdown]
        # Refresh the repoyard meta file

        # %%
        from repoyard._models import refresh_repoyard_meta

        refresh_repoyard_meta(config)

    finally:
        _sync_lock.release()
    return new_index_name
