# AUTOGENERATED! DO NOT EDIT!

from pathlib import Path
import asyncio

from .._utils.sync_helper import sync_helper, SyncSetting, SyncDirection
from .._models import SyncStatus, RepoPart
from ..config import get_config, StorageType
from .._utils import (
    check_interrupted,
    enable_soft_interruption,
    SoftInterruption,
)
from .._utils.locking import RepoyardLockManager, LockAcquisitionError, REPO_SYNC_LOCK_TIMEOUT, acquire_lock_async
from .. import const
from filelock import FileLock

async def sync_repo(
    config_path: Path,
    repo_index_name: str,
    sync_direction: SyncDirection | None = None,
    sync_setting: SyncSetting = SyncSetting.CAREFUL,
    sync_choices: list[RepoPart] | None = None,
    verbose: bool = False,
    show_rclone_progress: bool = False,
    soft_interruption_enabled: bool = True,
) -> dict[RepoPart, SyncStatus]:
    """
    Syncs a repo with its remote.
    
    Args:
        config_path: Path to the repoyard config file.
        repo_index_name: Full name of the repository to sync.
        sync_direction: Direction of sync.
        sync_setting: SyncSetting option (SAFE, CAREFUL, FORCE).
        sync_choices: List of RepoPart specifying what to sync. If None, all parts are synced.
        force: Force syncing, possibly overwriting changes.
        verbose: Print verbose output during sync.
        show_rclone_progress: Show rclone progress during sync.
    """
    config = get_config(config_path)
    if sync_choices is None:
        sync_choices = [repo_part for repo_part in RepoPart]
    
    if soft_interruption_enabled:
        enable_soft_interruption()
    from repoyard._models import get_repoyard_meta
    
    repoyard_meta = get_repoyard_meta(config)
    
    if repo_index_name not in repoyard_meta.by_index_name:
        raise ValueError(f"Repo '{repo_index_name}' not found.")
    
    repo_meta = repoyard_meta.by_index_name[repo_index_name]
    if repo_meta.get_storage_location_config(config).storage_type == StorageType.LOCAL:
        pass
        return
    _lock_manager = RepoyardLockManager(config.repoyard_data_path)
    _lock_path = _lock_manager.repo_sync_lock_path(repo_index_name)
    _lock_manager._ensure_lock_dir(_lock_path)
    _sync_lock = FileLock(_lock_path)
    await acquire_lock_async(
        _sync_lock,
        f"repo sync ({repo_index_name})",
        _lock_path,
        REPO_SYNC_LOCK_TIMEOUT
    )
    if verbose:
        print(f"Syncing repo {repo_index_name} at {repo_meta.storage_location}.")
    sl_config = repo_meta.get_storage_location_config(config)
    local_sync_backups_path = config.local_sync_backups_path
    remote_sync_backups_path = sl_config.store_path / const.REMOTE_BACKUP_REL_PATH
    sync_results = {}
    
    if check_interrupted():
        raise SoftInterruption()
    
    sync_part = RepoPart.META
    if sync_part in sync_choices:
        if verbose:
            print(f"Syncing {sync_part.value}.")
        sync_results[RepoPart.META] = await sync_helper(
            rclone_config_path=config.rclone_config_path,
            sync_direction=sync_direction,
            sync_setting=sync_setting,
            local_path=repo_meta.get_local_part_path(config, RepoPart.META),
            local_sync_record_path=repo_meta.get_local_sync_record_path(config, sync_part),
            remote=repo_meta.storage_location,
            remote_path=repo_meta.get_remote_part_path(config, RepoPart.META),
            remote_sync_record_path=repo_meta.get_remote_sync_record_path(
                config, sync_part
            ),
            local_sync_backups_path=local_sync_backups_path,
            remote_sync_backups_path=remote_sync_backups_path,
            verbose=verbose,
            show_rclone_progress=show_rclone_progress,
        )
    if check_interrupted():
        raise SoftInterruption()
    
    sync_part = RepoPart.CONF
    if sync_part in sync_choices:
        if verbose:
            print("Syncing", sync_part.value)
        sync_results[sync_part] = await sync_helper(
            rclone_config_path=config.rclone_config_path,
            sync_direction=sync_direction,
            sync_setting=sync_setting,
            local_path=repo_meta.get_local_part_path(config, RepoPart.CONF),
            local_sync_record_path=repo_meta.get_local_sync_record_path(config, sync_part),
            remote=repo_meta.storage_location,
            remote_path=repo_meta.get_remote_part_path(config, RepoPart.CONF),
            remote_sync_record_path=repo_meta.get_remote_sync_record_path(
                config, sync_part
            ),
            local_sync_backups_path=local_sync_backups_path,
            remote_sync_backups_path=remote_sync_backups_path,
            verbose=verbose,
            show_rclone_progress=show_rclone_progress,
        )
    _rclone_include_path = (
        repo_meta.get_local_part_path(config, RepoPart.CONF) / ".rclone_include"
    )
    _rclone_exclude_path = (
        repo_meta.get_local_part_path(config, RepoPart.CONF) / ".rclone_exclude"
    )
    _rclone_filters_path = (
        repo_meta.get_local_part_path(config, RepoPart.CONF) / ".rclone_filters"
    )
    
    _rclone_include_path = _rclone_include_path if _rclone_include_path.exists() else None
    _rclone_exclude_path = (
        _rclone_exclude_path
        if _rclone_exclude_path.exists()
        else config.default_rclone_exclude_path
    )
    _rclone_filters_path = _rclone_filters_path if _rclone_filters_path.exists() else None
    if check_interrupted():
        raise SoftInterruption()
    
    sync_part = RepoPart.DATA
    if sync_part in sync_choices:
        if verbose:
            print("Syncing", sync_part.value)
        sync_results[sync_part] = await sync_helper(
            rclone_config_path=config.rclone_config_path,
            sync_direction=sync_direction,
            sync_setting=sync_setting,
            local_path=repo_meta.get_local_part_path(config, RepoPart.DATA),
            local_sync_record_path=repo_meta.get_local_sync_record_path(config, sync_part),
            remote=repo_meta.storage_location,
            remote_path=repo_meta.get_remote_part_path(config, RepoPart.DATA),
            remote_sync_record_path=repo_meta.get_remote_sync_record_path(
                config, sync_part
            ),
            local_sync_backups_path=local_sync_backups_path,
            remote_sync_backups_path=remote_sync_backups_path,
            include_path=_rclone_include_path,
            exclude_path=_rclone_exclude_path,
            filters_path=_rclone_filters_path,
            verbose=verbose,
            show_rclone_progress=show_rclone_progress,
        )
    if RepoPart.META in sync_choices:
        from repoyard._models import refresh_repoyard_meta
    
        refresh_repoyard_meta(config)
    if _sync_lock.is_locked:
        _sync_lock.release()
    return sync_results
