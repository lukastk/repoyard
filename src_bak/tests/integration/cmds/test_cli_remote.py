# AUTOGENERATED! DO NOT EDIT!

import asyncio
from pathlib import Path

import pytest
from dotenv import load_dotenv

from repoyard._models import RepoPart, get_repoyard_meta
from repoyard.cmds import *
from repoyard.config import get_config

from ...integration.conftest import CmdFailed, run_cmd, run_cmd_in_background


@pytest.mark.integration
def test_cli_remote():
    """Test CLI commands with a real remote storage backend."""
    asyncio.run(_test_cli_remote())


async def _test_cli_remote():
    load_dotenv()
    import os

    if (
        "TEST_CONF_PATH" not in os.environ
        or "TEST_STORAGE_LOCATION_NAME" not in os.environ
        or "TEST_STORAGE_LOCATION_STORE_PATH" not in os.environ
    ):
        pytest.skip(
            "Environment variable TEST_CONF_PATH or TEST_STORAGE_LOCATION_NAME or "
            "TEST_STORAGE_LOCATION_STORE_PATH not set."
        )
    else:
        config_path = Path(os.environ["TEST_CONF_PATH"]).expanduser().resolve()
        config = get_config(config_path)
        sl_name = os.environ["TEST_STORAGE_LOCATION_NAME"]
        sl_store_path = os.environ["TEST_STORAGE_LOCATION_STORE_PATH"]
    try:
        run_cmd("repoyard")
    except CmdFailed:
        pytest.skip("repoyard not installed")
    repo_index_name1 = run_cmd(f"repoyard new -n test-repo-1 -g repoyard-unit-tests -s {sl_name}").strip()
    run_cmd(f"repoyard sync -r {repo_index_name1}", capture_output=True)
    repo_index_name2 = run_cmd(f"repoyard new -n test-repo-2 -g repoyard-unit-tests -s {sl_name}").strip()
    repo_index_name3 = run_cmd(f"repoyard new -n test-repo-3 -g repoyard-unit-tests -s {sl_name}").strip()

    p1 = run_cmd_in_background(f"repoyard sync -r {repo_index_name2}", print_output=False)
    p2 = run_cmd_in_background(f"repoyard sync -r {repo_index_name3}", print_output=False)

    p1.wait()
    p2.wait()
    repoyard_meta = get_repoyard_meta(config, force_create=True)
    repo_meta1 = repoyard_meta.by_index_name[repo_index_name1]
    repo_meta2 = repoyard_meta.by_index_name[repo_index_name2]
    repo_meta3 = repoyard_meta.by_index_name[repo_index_name3]

    from repoyard._utils import rclone_lsjson

    for repo_meta in [repo_meta1, repo_meta2, repo_meta3]:
        assert (
            await rclone_lsjson(
                config.rclone_config_path,
                source=sl_name,
                source_path=repo_meta.get_remote_path(config),
            )
            is not None
        )
    for repo_meta in [repo_meta1, repo_meta2, repo_meta3]:
        run_cmd(f"repoyard exclude -r {repo_meta.index_name}")

    async def _task(repo_meta):
        assert (
            await rclone_lsjson(
                config.rclone_config_path,
                source="",
                source_path=repo_meta.get_local_part_path(config, RepoPart.DATA),
            )
            is None
        )

    await asyncio.gather(*[_task(repo_meta) for repo_meta in [repo_meta1, repo_meta2, repo_meta3]])
    for repo_meta in [repo_meta1, repo_meta2, repo_meta3]:
        run_cmd(f"repoyard include -r {repo_meta.index_name}")

    async def _task(repo_meta):
        assert (
            await rclone_lsjson(
                config.rclone_config_path,
                source="",
                source_path=repo_meta.get_local_part_path(config, RepoPart.DATA),
            )
            is not None
        )

    await asyncio.gather(*[_task(repo_meta) for repo_meta in [repo_meta1, repo_meta2, repo_meta3]])
    for repo_meta in [repo_meta1, repo_meta2, repo_meta3]:
        run_cmd(f"repoyard delete -r {repo_meta.index_name}")

    async def _task(repo_meta):
        assert (
            await rclone_lsjson(
                config.rclone_config_path,
                source=sl_name,
                source_path=repo_meta.get_remote_path(config),
            )
            is None
        )

    await asyncio.gather(*[_task(repo_meta) for repo_meta in [repo_meta1, repo_meta2, repo_meta3]])
