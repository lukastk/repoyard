# AUTOGENERATED! DO NOT EDIT! File to edit: pts/tests/unit/_utils/test_logical_expressions.pct.py

__all__ = [
    "test_and_both_missing",
    "test_and_both_present",
    "test_and_chained",
    "test_and_left_missing",
    "test_and_right_missing",
    "test_case_sensitive_group_names",
    "test_complex_expression_with_all_operators",
    "test_complex_group_names",
    "test_deeply_nested_parens",
    "test_double_and_raises",
    "test_double_not",
    "test_double_or_raises",
    "test_empty_expression_raises",
    "test_empty_parens_raises",
    "test_extra_spaces_between_tokens",
    "test_filter_func_does_not_modify_input",
    "test_filter_func_is_reusable",
    "test_group_name_resembling_and",
    "test_group_name_resembling_not",
    "test_group_name_resembling_or",
    "test_groups_not_in_expression",
    "test_hyphenated_names",
    "test_invalid_character_raises",
    "test_leading_and_raises",
    "test_leading_or_raises",
    "test_leading_trailing_spaces",
    "test_lowercase_and",
    "test_lowercase_not",
    "test_lowercase_or",
    "test_mixed_case_operators",
    "test_nested_parens",
    "test_no_spaces_around_parens",
    "test_not_empty_groups",
    "test_not_group_absent",
    "test_not_group_present",
    "test_numeric_group_names",
    "test_or_both_present",
    "test_or_chained",
    "test_or_left_only",
    "test_or_neither_present",
    "test_or_right_only",
    "test_parens_override_precedence",
    "test_parens_with_not",
    "test_pipe_character_raises",
    "test_precedence_and_binds_tighter_than_or",
    "test_precedence_complex",
    "test_precedence_not_binds_tighter_than_and",
    "test_precedence_not_binds_tighter_than_or",
    "test_scenario_backend_not_deprecated",
    "test_scenario_complex_project_filter",
    "test_scenario_hierarchical_groups",
    "test_scenario_multiple_environments",
    "test_simple_alphanumeric_names",
    "test_single_char_names",
    "test_single_group_empty_groups",
    "test_single_group_match",
    "test_single_group_no_match",
    "test_single_group_with_set_input",
    "test_slashed_names",
    "test_spaces_around_parens",
    "test_trailing_and_raises",
    "test_trailing_or_raises",
    "test_underscored_names",
    "test_unmatched_close_paren_raises",
    "test_unmatched_open_paren_raises",
    "test_whitespace_only_expression_raises",
]

# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 2
import pytest

from repoyard._utils.logical_expressions import get_group_filter_func


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 4
def test_single_group_match():
    """Single group name matches when present in groups."""
    filter_func = get_group_filter_func("backend")
    assert filter_func(["backend", "api"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 5
def test_single_group_no_match():
    """Single group name doesn't match when absent from groups."""
    filter_func = get_group_filter_func("backend")
    assert filter_func(["api", "frontend"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 6
def test_single_group_with_set_input():
    """Filter function accepts set input."""
    filter_func = get_group_filter_func("backend")
    assert filter_func({"backend", "api"}) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 7
def test_single_group_empty_groups():
    """Single group doesn't match empty group list."""
    filter_func = get_group_filter_func("backend")
    assert filter_func([]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 9
def test_and_both_present():
    """AND returns True when both groups are present."""
    filter_func = get_group_filter_func("backend AND api")
    assert filter_func(["backend", "api", "v2"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 10
def test_and_left_missing():
    """AND returns False when left group is missing."""
    filter_func = get_group_filter_func("backend AND api")
    assert filter_func(["api", "frontend"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 11
def test_and_right_missing():
    """AND returns False when right group is missing."""
    filter_func = get_group_filter_func("backend AND api")
    assert filter_func(["backend", "frontend"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 12
def test_and_both_missing():
    """AND returns False when both groups are missing."""
    filter_func = get_group_filter_func("backend AND api")
    assert filter_func(["frontend", "legacy"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 13
def test_and_chained():
    """Chained AND operators work correctly."""
    filter_func = get_group_filter_func("a AND b AND c")
    assert filter_func(["a", "b", "c"]) == True
    assert filter_func(["a", "b"]) == False
    assert filter_func(["a", "c"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 15
def test_or_both_present():
    """OR returns True when both groups are present."""
    filter_func = get_group_filter_func("backend OR api")
    assert filter_func(["backend", "api"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 16
def test_or_left_only():
    """OR returns True when only left group is present."""
    filter_func = get_group_filter_func("backend OR api")
    assert filter_func(["backend", "frontend"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 17
def test_or_right_only():
    """OR returns True when only right group is present."""
    filter_func = get_group_filter_func("backend OR api")
    assert filter_func(["api", "frontend"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 18
def test_or_neither_present():
    """OR returns False when neither group is present."""
    filter_func = get_group_filter_func("backend OR api")
    assert filter_func(["frontend", "legacy"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 19
def test_or_chained():
    """Chained OR operators work correctly."""
    filter_func = get_group_filter_func("a OR b OR c")
    assert filter_func(["a"]) == True
    assert filter_func(["b"]) == True
    assert filter_func(["c"]) == True
    assert filter_func(["d"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 21
def test_not_group_present():
    """NOT returns False when group is present."""
    filter_func = get_group_filter_func("NOT deprecated")
    assert filter_func(["deprecated", "backend"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 22
def test_not_group_absent():
    """NOT returns True when group is absent."""
    filter_func = get_group_filter_func("NOT deprecated")
    assert filter_func(["backend", "api"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 23
def test_not_empty_groups():
    """NOT returns True for empty group list."""
    filter_func = get_group_filter_func("NOT deprecated")
    assert filter_func([]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 24
def test_double_not():
    """Double NOT cancels out."""
    filter_func = get_group_filter_func("NOT NOT backend")
    assert filter_func(["backend"]) == True
    assert filter_func(["api"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 26
def test_precedence_and_binds_tighter_than_or():
    """AND binds tighter than OR: 'a OR b AND c' == 'a OR (b AND c)'"""
    filter_func = get_group_filter_func("a OR b AND c")
    # Should be equivalent to: a OR (b AND c)
    # With groups [a]: a=T, b=F, c=F -> T OR (F AND F) -> T OR F -> T
    assert filter_func(["a"]) == True
    # With groups [b, c]: a=F, b=T, c=T -> F OR (T AND T) -> F OR T -> T
    assert filter_func(["b", "c"]) == True
    # With groups [b]: a=F, b=T, c=F -> F OR (T AND F) -> F OR F -> F
    assert filter_func(["b"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 27
def test_precedence_not_binds_tighter_than_and():
    """NOT binds tighter than AND: 'NOT a AND b' == '(NOT a) AND b'"""
    filter_func = get_group_filter_func("NOT a AND b")
    # Should be equivalent to: (NOT a) AND b
    # With groups [b]: a=F, b=T -> (NOT F) AND T -> T AND T -> T
    assert filter_func(["b"]) == True
    # With groups [a, b]: a=T, b=T -> (NOT T) AND T -> F AND T -> F
    assert filter_func(["a", "b"]) == False
    # With groups [a]: a=T, b=F -> (NOT T) AND F -> F AND F -> F
    assert filter_func(["a"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 28
def test_precedence_not_binds_tighter_than_or():
    """NOT binds tighter than OR: 'NOT a OR b' == '(NOT a) OR b'"""
    filter_func = get_group_filter_func("NOT a OR b")
    # Should be equivalent to: (NOT a) OR b
    # With groups []: a=F, b=F -> (NOT F) OR F -> T OR F -> T
    assert filter_func([]) == True
    # With groups [a]: a=T, b=F -> (NOT T) OR F -> F OR F -> F
    assert filter_func(["a"]) == False
    # With groups [a, b]: a=T, b=T -> (NOT T) OR T -> F OR T -> T
    assert filter_func(["a", "b"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 29
def test_precedence_complex():
    """Complex expression: 'NOT a OR b AND c' == '(NOT a) OR (b AND c)'"""
    filter_func = get_group_filter_func("NOT a OR b AND c")
    # Should be equivalent to: (NOT a) OR (b AND c)
    # With groups []: -> (NOT F) OR (F AND F) -> T OR F -> T
    assert filter_func([]) == True
    # With groups [a]: -> (NOT T) OR (F AND F) -> F OR F -> F
    assert filter_func(["a"]) == False
    # With groups [b, c]: -> (NOT F) OR (T AND T) -> T OR T -> T
    assert filter_func(["b", "c"]) == True
    # With groups [a, b, c]: -> (NOT T) OR (T AND T) -> F OR T -> T
    assert filter_func(["a", "b", "c"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 31
def test_parens_override_precedence():
    """Parentheses override default precedence."""
    filter_func = get_group_filter_func("(a OR b) AND c")
    # Without parens: a OR (b AND c)
    # With parens: (a OR b) AND c
    # Groups [a, c]: (T OR F) AND T -> T AND T -> T
    assert filter_func(["a", "c"]) == True
    # Groups [a]: (T OR F) AND F -> T AND F -> F
    assert filter_func(["a"]) == False
    # Groups [b, c]: (F OR T) AND T -> T AND T -> T
    assert filter_func(["b", "c"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 32
def test_parens_with_not():
    """NOT with parentheses: 'NOT (a AND b)'"""
    filter_func = get_group_filter_func("NOT (a AND b)")
    # NOT (a AND b)
    # Groups [a, b]: NOT (T AND T) -> NOT T -> F
    assert filter_func(["a", "b"]) == False
    # Groups [a]: NOT (T AND F) -> NOT F -> T
    assert filter_func(["a"]) == True
    # Groups []: NOT (F AND F) -> NOT F -> T
    assert filter_func([]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 33
def test_nested_parens():
    """Nested parentheses work correctly."""
    filter_func = get_group_filter_func("((a OR b) AND c)")
    assert filter_func(["a", "c"]) == True
    assert filter_func(["b", "c"]) == True
    assert filter_func(["c"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 34
def test_deeply_nested_parens():
    """Deeply nested parentheses."""
    filter_func = get_group_filter_func("((a AND (b OR c)) OR (d AND e))")
    # (a AND (b OR c)) OR (d AND e)
    assert filter_func(["a", "b"]) == True  # (T AND T) OR F -> T
    assert filter_func(["a", "c"]) == True  # (T AND T) OR F -> T
    assert filter_func(["d", "e"]) == True  # F OR T -> T
    assert filter_func(["a"]) == False  # (T AND F) OR F -> F
    assert filter_func(["d"]) == False  # F OR F -> F


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 35
def test_complex_expression_with_all_operators():
    """Complex expression using all operators and parentheses."""
    filter_func = get_group_filter_func("(backend OR frontend) AND NOT (deprecated OR legacy)")
    # True cases: has backend or frontend, and doesn't have deprecated or legacy
    assert filter_func(["backend"]) == True
    assert filter_func(["frontend"]) == True
    assert filter_func(["backend", "api"]) == True
    # False cases: missing backend/frontend
    assert filter_func(["api"]) == False
    # False cases: has deprecated or legacy
    assert filter_func(["backend", "deprecated"]) == False
    assert filter_func(["frontend", "legacy"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 37
def test_extra_spaces_between_tokens():
    """Extra spaces between tokens are handled."""
    filter_func = get_group_filter_func("a  AND  b")
    assert filter_func(["a", "b"]) == True
    assert filter_func(["a"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 38
def test_leading_trailing_spaces():
    """Leading and trailing spaces are handled."""
    filter_func = get_group_filter_func("  a AND b  ")
    assert filter_func(["a", "b"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 39
def test_spaces_around_parens():
    """Spaces around parentheses are handled."""
    filter_func = get_group_filter_func("( a OR b ) AND c")
    assert filter_func(["a", "c"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 40
def test_no_spaces_around_parens():
    """No spaces around parentheses works."""
    filter_func = get_group_filter_func("(a OR b)AND c")
    assert filter_func(["a", "c"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 42
def test_lowercase_and():
    """Lowercase 'and' operator works."""
    filter_func = get_group_filter_func("a and b")
    assert filter_func(["a", "b"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 43
def test_lowercase_or():
    """Lowercase 'or' operator works."""
    filter_func = get_group_filter_func("a or b")
    assert filter_func(["a"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 44
def test_lowercase_not():
    """Lowercase 'not' operator works."""
    filter_func = get_group_filter_func("not a")
    assert filter_func(["b"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 45
def test_mixed_case_operators():
    """Mixed case operators work."""
    filter_func = get_group_filter_func("a And b Or c")
    assert filter_func(["a", "b"]) == True
    assert filter_func(["c"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 47
def test_simple_alphanumeric_names():
    """Simple alphanumeric group names."""
    filter_func = get_group_filter_func("backend123")
    assert filter_func(["backend123"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 48
def test_hyphenated_names():
    """Hyphenated group names work."""
    filter_func = get_group_filter_func("my-group AND other-group")
    assert filter_func(["my-group", "other-group"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 49
def test_underscored_names():
    """Underscored group names work."""
    filter_func = get_group_filter_func("my_group AND other_group")
    assert filter_func(["my_group", "other_group"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 50
def test_slashed_names():
    """Slashed group names (hierarchical) work."""
    filter_func = get_group_filter_func("category/subcategory")
    assert filter_func(["category/subcategory"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 51
def test_complex_group_names():
    """Complex group names with mixed characters."""
    filter_func = get_group_filter_func("my-project_v2/prod AND api-v3")
    assert filter_func(["my-project_v2/prod", "api-v3"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 52
def test_numeric_group_names():
    """Purely numeric group names work."""
    filter_func = get_group_filter_func("2024 AND v2")
    assert filter_func(["2024", "v2"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 53
def test_single_char_names():
    """Single character group names work."""
    filter_func = get_group_filter_func("a AND b")
    assert filter_func(["a", "b"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 55
def test_empty_expression_raises():
    """Empty expression raises ValueError."""
    with pytest.raises(ValueError, match="Empty expression"):
        get_group_filter_func("")


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 56
def test_whitespace_only_expression_raises():
    """Whitespace-only expression raises ValueError."""
    with pytest.raises(ValueError, match="Empty expression"):
        get_group_filter_func("   ")


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 57
def test_unmatched_open_paren_raises():
    """Unmatched opening parenthesis raises ValueError."""
    with pytest.raises(ValueError, match="[Uu]nmatched"):
        filter_func = get_group_filter_func("(a AND b")
        filter_func(["a", "b"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 58
def test_unmatched_close_paren_raises():
    """Unmatched closing parenthesis raises ValueError."""
    with pytest.raises(ValueError, match="[Uu]nexpected"):
        filter_func = get_group_filter_func("a AND b)")
        filter_func(["a", "b"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 59
def test_trailing_and_raises():
    """Trailing AND operator raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("a AND")
        filter_func(["a"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 60
def test_trailing_or_raises():
    """Trailing OR operator raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("a OR")
        filter_func(["a"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 61
def test_leading_and_raises():
    """Leading AND operator raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("AND a")
        filter_func(["a"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 62
def test_leading_or_raises():
    """Leading OR operator raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("OR a")
        filter_func(["a"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 63
def test_double_and_raises():
    """Double AND operator raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("a AND AND b")
        filter_func(["a", "b"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 64
def test_double_or_raises():
    """Double OR operator raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("a OR OR b")
        filter_func(["a", "b"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 65
def test_invalid_character_raises():
    """Invalid character in expression raises ValueError."""
    with pytest.raises(ValueError, match="Invalid character"):
        get_group_filter_func("a & b")


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 66
def test_pipe_character_raises():
    """Pipe character raises ValueError."""
    with pytest.raises(ValueError, match="Invalid character"):
        get_group_filter_func("a | b")


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 67
def test_empty_parens_raises():
    """Empty parentheses raises ValueError."""
    with pytest.raises(ValueError):
        filter_func = get_group_filter_func("a AND ()")
        filter_func(["a"])


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 69
def test_group_name_resembling_and():
    """Group name that starts like 'and' but isn't.

    The tokenizer correctly requires word boundaries for operators,
    so 'android' is treated as an identifier, not 'AND' + 'roid'.
    """
    filter_func = get_group_filter_func("android AND api")
    assert filter_func(["android", "api"]) == True
    assert filter_func(["android"]) == False
    assert filter_func(["api"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 70
def test_group_name_resembling_or():
    """Group name that starts like 'or' but isn't.

    The tokenizer correctly requires word boundaries for operators,
    so 'oracle' is treated as an identifier, not 'OR' + 'acle'.
    """
    filter_func = get_group_filter_func("oracle AND api")
    assert filter_func(["oracle", "api"]) == True
    assert filter_func(["oracle"]) == False
    assert filter_func(["api"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 71
def test_group_name_resembling_not():
    """Group name that starts like 'not' but isn't.

    The tokenizer correctly requires word boundaries for operators,
    so 'notebook' is treated as an identifier, not 'NOT' + 'ebook'.
    """
    filter_func = get_group_filter_func("notebook AND api")
    assert filter_func(["notebook", "api"]) == True
    assert filter_func(["notebook"]) == False
    assert filter_func(["api"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 72
def test_filter_func_is_reusable():
    """Filter function can be called multiple times."""
    filter_func = get_group_filter_func("a AND b")
    assert filter_func(["a", "b"]) == True
    assert filter_func(["a"]) == False
    assert filter_func(["a", "b", "c"]) == True
    assert filter_func([]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 73
def test_filter_func_does_not_modify_input():
    """Filter function doesn't modify input list."""
    groups = ["a", "b"]
    original = groups.copy()
    filter_func = get_group_filter_func("a AND b")
    filter_func(groups)
    assert groups == original


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 74
def test_groups_not_in_expression():
    """Groups not mentioned in expression don't affect result."""
    filter_func = get_group_filter_func("a AND b")
    assert filter_func(["a", "b", "c", "d", "e"]) == True


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 75
def test_case_sensitive_group_names():
    """Group names are case-sensitive."""
    filter_func = get_group_filter_func("Backend")
    assert filter_func(["Backend"]) == True
    assert filter_func(["backend"]) == False
    assert filter_func(["BACKEND"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 77
def test_scenario_backend_not_deprecated():
    """Real scenario: backend services not deprecated."""
    filter_func = get_group_filter_func("backend AND NOT deprecated")
    assert filter_func(["backend", "api"]) == True
    assert filter_func(["backend", "deprecated"]) == False
    assert filter_func(["frontend"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 78
def test_scenario_multiple_environments():
    """Real scenario: prod or staging, not legacy."""
    filter_func = get_group_filter_func("(prod OR staging) AND NOT legacy")
    assert filter_func(["prod", "backend"]) == True
    assert filter_func(["staging", "frontend"]) == True
    assert filter_func(["prod", "legacy"]) == False
    assert filter_func(["dev"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 79
def test_scenario_hierarchical_groups():
    """Real scenario: hierarchical group filtering."""
    filter_func = get_group_filter_func("company/team-a OR company/team-b")
    assert filter_func(["company/team-a"]) == True
    assert filter_func(["company/team-b"]) == True
    assert filter_func(["company/team-c"]) == False


# %% pts/tests/unit/_utils/test_logical_expressions.pct.py 80
def test_scenario_complex_project_filter():
    """Real scenario: complex project filtering."""
    expr = "(backend OR frontend) AND (prod OR staging) AND NOT (deprecated OR archived)"
    filter_func = get_group_filter_func(expr)
    # Should match
    assert filter_func(["backend", "prod"]) == True
    assert filter_func(["frontend", "staging"]) == True
    assert filter_func(["backend", "frontend", "prod"]) == True
    # Should not match - missing environment
    assert filter_func(["backend"]) == False
    # Should not match - deprecated
    assert filter_func(["backend", "prod", "deprecated"]) == False
    # Should not match - archived
    assert filter_func(["frontend", "staging", "archived"]) == False
